<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="/js/kodumaro.js"></script>
<script language="javascript">
//<@[CDATA[
    document.title += ' :: Standard ML – continuação';
//]]></script>


<div class="panel panel-default">
    <div class="panel-heading">
        <h2 class="mg-title">Kodumaro :: Standard ML – continuação</h2>
    </div>
    <div class="panel-body">
        <p class="mg-first">
            No <a href="/?t=/kodumaro/2016/03/sml">artigo anterior</a> vimos
            como criar funções que retornem uma sequência de inteiros. Porém,
            para estendê-las para gerarem uma sequência de caracteres, por
            exemplo, teríamos de reescrever o código.
        </p>
        <p>
            Neste artigo mudaremos o código para torná-lo estensível a outros
            tipos usando um <em>functor</em>
        </p>
        <p>
            Módulos em Standard ML são chamados <em>structures</em> e podem ser
            instanciados sob demanda com o uso de <em>functors</em>. A primeira
            coisa que precisamos é da assinatura dos módulos gerados pelo
            <em>functor</em>.
        </p>
        <p>
            Os módulos gerados precisam ter o tipo de dado (<code>t</code>), uma
            função para construir o gerador (<code>build</code>) e outra para
            converter o gerador em list (<code>genToList</code>). A assinatura
            fica assim então:
        </p>
        <pre class="prettyprint"><code class="language-ml">signature GENERATOR =
sig
  eqtype t
  val genToList : (unit -&gt; t option) -&gt; t list
  val build : (t * t) -&gt; unit -&gt; t option
end</code></pre>
        <p>
            Também precisamos da assinatura da <em>structure</em> usada como
            parâmetro do <em>functor</em>. Essa <em>structure</em> deve
            gerenciar a reiteração dos dados. Para tanto, deve conhecer o tipo
            de dado (<code>t</code>), ter uma função para fazer o passo, ou
            seja, incrementar o dado (<code>increment</code>), e outra para
            testar a condição de parada (<code>checkFinish</code>).
        </p>
        <p>
            A assinatura fica assim então:
        </p>
        <pre class="prettyprint"><code class="language-ml">signature GENERATOR' =
sig
  eqtype t
  val increment : t ref -&gt; unit
  val checkFinish : t ref -&gt; t -&gt; bool
end</code></pre>
        <p>
            O <em>functor</em> terá praticamente o mesmo código de nossas
            funções originais, mas agora será extensível.
        </p>
        <p>
            Vamos então trazer o código para o <em>functor</em>:
        </p>
        <pre class="prettyprint"><code class="language-ml">functor Generator (G : GENERATOR') : GENERATOR =
struct
  type t = G.t

  local
    fun genToList' (acc : t list) (gen : unit -&gt; t option) : t list =
      case gen () of NONE       =&gt; rev acc
                   | SOME value =&gt; genToList' (value::acc) gen
  in
    val genToList = genToList' nil
  end

  local
    fun build' i finish () =
      if G.checkFinish i finish then
        NONE
      else
        let
          val r = !i
        in
          G.increment i;
          SOME r
        end
  in
    fun build (start, finish) = build' (ref start) finish
  end
end</code></pre>
        <p>
            Repare que agora em vez de <code>int</code> estamos usando
            <code>t</code> (que é igual a <code>G.t</code>), e delegamos a
            verificação do fim da reiteração e o incremento da referência para
            <code>G</code>.
        </p>
        <p>
            Resta agora recriar nossas funções originais. Como só nos interessam
            <em>xrange</em> e <em>range</em>, podemos criar a
            <code>structure</code> como <code>local</code>:
        </p>
        <pre class="prettyprint"><code class="language-ml">local
  structure IntGenerator = Generator (struct
    type t = int

    fun increment v : unit = v := !v + 1
    and checkFinish i finish = !i &gt;= finish
  end)
in
  val xrange = IntGenerator.build
  val range = IntGenerator.genToList o xrange
</code></pre>
        <p>
            E para criar funções equivalentes para caracteres? A lógica é a
            mesma:
        </p>
        <pre class="prettyprint"><code class="language-ml">local
  structure StringGenerator = Generator (struct
    type t = char

    fun increment v : unit = v := chr (ord (!v) + 1)
    and checkFinish (i : char ref) (finish : char) = !i &gt; finish
  end)
in
  val xcharseq = StringGenerator.build
  val strseq = implode o StringGenerator.genToList o StringGenerator.build
end</code></pre>
        <p>
            Veja que agora podemos com facilidade estender o lógica de criação
            de geradores para virtualmente qualquer tipo, com a ajuda do
            <em>functor</em>.
        </p>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-body" align="right">
        <small><a href="https://github.com/cacilhas/cacilhas.github.io/issues/new?title=Kodumaro+::+Standard+ML+2" target="_blank">Criar
                <em>issue</em></a></small>
    </div>
</div>
