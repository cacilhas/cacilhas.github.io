<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="/js/kodumaro.js"></script>
<script language="javascript">
//<@[CDATA[
    document.title += ' :: Standard ML';
    $('#footer > p').text('Por: Arƒ•imedeœÇ ‚Ñ≥ontegasppŒ± ‚Ñ≠acilhŒ±œÇ');
//]]></script>

<div class="panel panel-default">
    <div class="panel-heading">
        <h2 class="mg-title">Kodumaro :: Standard ML</h2>
        <h6>As sombras da programa√ß√£o.</h6>
    </div>
    <div class="panel-body">
        <p class="mg-first">
            <a href="http://sml-family.org/">Standard ML</a> √© a defini√ß√£o
            padr√£o (<em>standard</em>, duh) de
            <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>,
            uma fam√≠lia de linguagens de programa√ß√£o funcional impura. O
            representante mais expressivo dessa fam√≠lia √© a linguagem francesa
            <a href="http://caml.inria.fr/">OCaml</a>, e uma linguagem prima √©
            <a href="https://www.haskell.org/">Haskell</a>, um parente funcional
            puro.
        </p>
        <p>
            A implementa√ß√£o de Standard ML que recomendo √© a da
            <a href="http://www.cs.princeton.edu/">Princeton University</a>,
            <a href="http://www.smlnj.org/">SML/NJ</a>.
        </p>
        <p>
            Gostaria de, antes de tudo, pedir desculpas pelos c√≥digos que
            passarei aqui, pois Standard ML √© uma linguagem que n√£o domino,
            ent√£o alguns conceitos podem estar errados. Se quiser me enviar
            erratas, crie um <em>issue</em> no
            <a href="https://github.com/cacilhas/cacilhas.github.io/issues">GitHub</a>.
        </p>

        <h3>Linguagem funcional pura vs impura</h3>
        <p>
            Para uma linguagem ser considerada funcional pura, ela precisa
            respeitar algumas <em>constraints</em>:
        </p>
        <ul class="list-group">
            <li class="list-group-item">
                <span class="glyphicon glyphicon-hand-right"></span>
                O algoritmo deve ser baseado em chamadas de fun√ß√£o, que recebem
                par√¢metros e retornam valores. O estado do programa n√£o muda,
                apenas os dados s√£o reconstru√≠dos atrav√©s do encadeamento de
                fun√ß√µes.
            </li>
            <li class="list-group-item">
                <span class="glyphicon glyphicon-hand-right"></span>
                As fun√ß√µes devem ser ‚Äúavaliadas‚Äù (n√£o achei palavra melhor) sob
                demanda, de modo n√£o-estrito.
            </li>
            <li class="list-group-item">
                <span class="glyphicon glyphicon-hand-right"></span>
                As fun√ß√µes devem ser idempotentes, seja, dado determinado(s)
                par√¢metro(s), ela deve invariavelmente retornar sempre o mesmo
                resultado.
            </li>
            <li class="list-group-item">
                <span class="glyphicon glyphicon-hand-right"></span>
                N√£o pode haver mudan√ßa de estado: uma vez um valor vinculado a
                um <em>slot</em>, n√£o pode ser mudado. Neste sentido, a palavra
                ‚Äúvari√°vel‚Äù n√£o representa bem o <em>slot</em>. Pessoalmente
                prefiro <strong>inc√≥gnita</strong>.
            </li>
            <li class="list-group-item">
                <span class="glyphicon glyphicon-hand-right"></span>
                Assim, <em>loops</em> s√£o resolvidos com recurs√£o. Para que a
                recurs√£o n√£o estoure a pilha de inst√¢ncias de fun√ß√£o, como
                ocorre em algumas linguagens imperativas, a m√°quina virtual ou
                interpretador precisa implementar
                <a href="https://en.wikipedia.org/wiki/Tail_call">Tail-call
                optimisation</a>.
            </li>
        </ul>
        <p>
            Se a linguagem funcional n√£o atende a todas as <em>constraints</em>
            ‚Äì ou atende parcialmente ‚Äì ela √© considerada impura.
        </p>
        <p>
            A fam√≠lia ML √© impura porque usa um recurso de linguagens
            imperativas: a mudan√ßa de estado. Assim uma vari√°vel do tipo
            refer√™ncia (<code>a' ref</code>) pode ter seu valor alterado.
            Havendo mudan√ßa de estado, uma fun√ß√£o pode n√£o ser idempotente.
        </p>
        <p>
            Por exemplo:
        </p>
        <pre class="prettyprint"><code class="language-ml">- val x = ref 0;
val x = ref 0 : int ref
- x := !x + 1;
val it = () : unit
- !x;
val it = 1 : int</code></pre>
        <p>
            A vari√°vel <code>x</code> foi criada como uma refer√™ncia a uma
            posi√ß√£o de mem√≥ria que guarda um inteiro, onde foi colocado o valor
            zero (<code>0</code>).
        </p>
        <p>
            Na avalia√ß√£o seguinte, o conte√∫do da posi√ß√£o de mem√≥ria referenciada
            por <code>x</code> foi incrementado. √â poss√≠vel ver na √∫ltima
            avalia√ß√£o que aquela posi√ß√£o de mem√≥ria agora guarda o valor
            <code>1</code>.
        </p>
        <p><small>
            As linguagens da fam√≠lia ML tamb√©m suportam que uma vari√°vel seja
            associada a outro valor.
        </small></p>

        <h3>Gerador de inteiros</h3>
        <p>
            Vamos ent√£o ao c√≥digo!!! üòÉ
        </p>
        <p>
            Vamos criar um gerador de n√∫meros inteiros e uma fun√ß√£o que use este
            gerador para gerar uma lista de n√∫meros inteiros.
        </p>
        <p>
            As assinaturas de nossas fun√ß√µes ser√£o:
        </p>
        <pre class="prettyprint"><code class="language-ml">val xrange : (int * int) -&gt; unit -&gt; int option
val range : (int * int) -&gt; int list</code></pre>
        <p>
            Tomei os nomes emprestados de
            <a href="https://docs.python.org/2.7/library/functions.html">Python 2.7</a>.
            <code>xrange</code> recebe como par√¢metro uma tupla de dois inteiros
            (<code>(int * int)</code>) e retorna uma fun√ß√£o que recebe uma
            <a href="https://en.wikipedia.org/wiki/Unit_type">unidade</a>,
            retornando uma ‚Äúop√ß√£o‚Äù de inteiro.
        </p>
        <p>
            A tupla recebidas por <code>xrange</code> representa o come√ßo e o
            fim da reitera√ß√£o.
        </p>
        <p>
            Ent√£o o par√¢metro <code>(a, b)</code> representa matematicamente
            reitera√ß√£o sobre o conjunto <tt>[a, b)</tt>.
        </p>
        <p>
            <code>range</code> recebe o mesmo tipo de par√¢metro que
            <code>xrange</code>, retornando a lista j√° composta.
        </p>
        <p>
            <span class="glyphicon glyphicon-alert mg-alert"></span>
            ‚Äî Mas o que diabos √© uma <strong>op√ß√£o</strong> de inteiro?
        </p>
        <p>
            √â um valor que <strong>pode ser</strong> ‚Äúalgum‚Äù (<code>SOME</code>)
            inteiro ou ‚Äúnenhum‚Äù (<code>NONE</code>).
        </p>
        <pre class="prettyprint"><code class="language-ml">- SOME 42;
val it = SOME 42 : int option
- NONE;
val it = NONE : 'a option</code></pre>
        <p>
            Usaremos <code>NONE</code> para marcar o fim da reitera√ß√£o.
            Precisamos tamb√©m de um
            <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"><em>closure</em></a>
            para armazenar o pr√≥ximo retorno do gerador (j√° que geradores n√£o
            s√£o idempotentes). Usaremos um <code>int ref</code> para o
            <em>closure</em>.
        </p>
        <p><small>
            Atualizei o c√≥digo removendo a necessidade de usar <code>fn</code>.
        </small></p>
        <pre class="prettyprint"><code class="language-ml">local
  fun xrange' i finish () =
    if !i &gt;= finish then
      NONE
    else
      let
        val r = !i
      in
        i := !i + 1;
        SOME r
      end
in
  fun xrange (start, finish) = xrange' (ref start) finish
end</code></pre>
        <p>
            Vamos testar nosso <code>xrange</code>:
        </p>
        <pre class="prettyprint"><code class="language-ml">- val x = range (0, 10);
val x = fn : unit -&gt; int option
- x ();
val it = SOME 0 : int option
- x ();
val it = SOME 1 : int option
- x ();
val it = SOME 2 : int option
- x ();
val it = SOME 3 : int option
- x ();
val it = SOME 4 : int option
- x ();
val it = SOME 5 : int option
- x ();
val it = SOME 6 : int option
- x ();
val it = SOME 7 : int option
- x ();
val it = SOME 8 : int option
- x ();
val it = SOME 9 : int option
- x ();
val it = NONE : int option</code></pre>
        <p>
            OK! Nossa fun√ß√£o se comporta como esperado! Agora precisamos criar
            a fun√ß√£o <code>range</code>.
        </p>

        <h3>Gerador para lista</h3>
        <p>
            Para criar a fun√ß√£o <code>range</code>, criaremos uma fun√ß√£o que
            receba um gerador e retorne uma lista de todos os valores gerados.
        </p>
        <p>
            Esta fun√ß√£o precisa de um acumulador: uma lista que come√ßa vazia
            (<code>nil</code>) e vai sendo preenchida conforme o gerador √©
            reiterado. Ent√£o ela precisa validar o gerador (passando a unidade
            como par√¢metro) e tratar o resultado:
        </p>
        <pre class="prettyprint"><code class="language-ml">fun genToList' (acc : int list) (gen : unit -&gt; int option) : int list =
  case gen () of NONE       =&gt; rev acc
               | SOME value =&gt; genToList' (value::acc) gen</code></pre>
        <p>
            Perceba que, passando <code>value::acc</code>, a lista √© gerada de
            tr√°s para frente. Portanto, ao recebermos o valor de parada
            (<code>NONE</code>), precisamos retornar a invers√£o do acumulador
            (<code>rev acc</code>).
        </p>
        </p>
        Nossa <code>genToList'</code> tem assinatura
            <code>int list -&gt; (unit -&gt; t option) -&gt; t list</code>, o
            que significa que, se chamada com um √∫nico par√¢metro (o acumulador),
            retorna uma fun√ß√£o com a assinatura
            <code>(unit -&gt; t option) -&gt; t list</code>. Vamos criar o
            variante com acumulador embutido:
        </p>
        <pre class="prettyprint"><code class="language-ml">val genToList = genToList' nil</code></pre>
        <p>
            Podemos usar essa segunda fun√ß√£o para construir a fun√ß√£o
            <code>range</code>. Colocando tudo junto:
        </p>
        <pre class="prettyprint"><code class="language-ml">local
  fun genToList' (acc : int list) (gen : unit -&gt; int option) : int list =
    case gen () of NONE       =&gt; rev acc
                 | SOME value =&gt; genToList' (value::acc) gen
  val genToList = genToList' nil
in
  val range = genToList o xrange
end</code></pre>
        <p>
            A constru√ß√£o <code>o</code> funciona como <tt>o</tt> de matem√°tica,
            por exemplo, <tt>fog(x)</tt> √© o mesmo que <tt>f(g(x))</tt>.
        </p>
        <p>
            Vamos testar:
        </p>
        <pre class="prettyprint"><code class="language-ml">- range (0, 10);
val it = [0,1,2,3,4,5,6,7,8,9] : int list</code></pre>
        <p>
            <em>It works!!!</em> üòã
        </p>

        <h3>Pr√≥ximo artigo</h3>
        <p>
            No <a href="/?t=/kodumaro/2016/03/sml-2">pr√≥ximo artigo</a> vamos
            tornar o gerador mais robusto e gen√©rico com <em>structures</em> e
            <em>functors</em>.
        </p>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-body" align="right">
        <small><a href="https://github.com/cacilhas/cacilhas.github.io/issues/new?title=Kodumaro+::+Standard+ML" target="_blank">Criar
                <em>issue</em></a></small>
    </div>
</div>
