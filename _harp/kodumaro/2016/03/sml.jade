include ../../../_includes/list-group-item.jade

p.mg-first
  a(href="http://sml-family.org/") Standard ML
  |  √© a defini√ß√£o padr√£o (#[em standard], duh) de#[=" "]
  a(href="https://en.wikipedia.org/wiki/ML_(programming_language)") ML
  | , uma fam√≠lia de linguagens de programa√ß√£o funcional impura. O representante
  | mais expressivo dessa fam√≠lia √© a linguagem francesa#[=" "]
  a(href="http://caml.inria.fr/") OCaml
  | , e uma linguagem prima √©#[=" "]
  a(href="https://www.haskell.org/") Haskell
  | , um parente funcional puro.

p A implementa√ß√£o de Standard ML que recomendo √© a da#[=" "]
  a(href="http://www.cs.princeton.edu/") Princeton University
  | ,#[=" "]
  a(href="http://www.smlnj.org/") SML/NJ
  | .

p Gostaria de, antes de tudo, pedir desculpas pelos c√≥digos que passarei aqui,
  | pois Standard ML √© uma linguagem que n√£o domino, ent√£o alguns conceitos
  |  podem estar errados. Se quiser me enviar erratas, comente abaixo.

h3 Linguagem funcional pura vs impura

p Para uma linguagem ser considerada funcional pura, ela precisa respeitar
  |  algumas #[em constraints]:

+ul
  +li
    | O algoritmo deve ser baseado em chamadas de fun√ß√£o, que recebem
    | par√¢metros e retornam valores. O estado do programa n√£o muda, apenas os
    | dados s√£o reconstru√≠dos atrav√©s do encadeamento de fun√ß√µes.

  +li
    | As fun√ß√µes devem ser ‚Äúavaliadas‚Äù (n√£o achei palavra melhor) sob demanda,
    | de modo n√£o-estrito.

  +li
    | As fun√ß√µes devem ser idempotentes, seja, dado determinado(s)
    | par√¢metro(s), ela deve invariavelmente retornar sempre o mesmo resultado.

  +li
    | N√£o pode haver mudan√ßa de estado: uma vez um valor vinculado a um
    |  #[em slot], n√£o pode ser mudado. Neste sentido, a palavra ‚Äúvari√°vel‚Äù n√£o
    |  representa bem o #[em slot]. Pessoalmente prefiro #[strong inc√≥gnita].

  +li
    | Assim, #[em loops] s√£o resolvidos com recurs√£o. Para que a recurs√£o n√£o
    | estoure a pilha de inst√¢ncias de fun√ß√£o, como ocorre em algumas linguagens
    | imperativas, a m√°quina virtual ou interpretador precisa implementar#[=" "]
    a(href="https://en.wikipedia.org/wiki/Tail_call") Tail-call optimisation
    | .

p Se a linguagem funcional n√£o atende a todas as #[em constraints] ‚Äì ou atende
  | parcialmente ‚Äì ela √© considerada impura.

p A fam√≠lia ML √© impura porque usa um recurso de linguagens imperativas: a
  | mudan√ßa de estado. Assim uma vari√°vel do tipo refer√™ncia (
  code a' ref
  | ) pode ter seu valor alterado. Havendo mudan√ßa de estado, uma fun√ß√£o pode
  | n√£o ser idempotente.

p Por exemplo:

pre.prettyprint: code.language-ml.
  - val x = ref 0;
  val x = ref 0 : int ref
  - x := !x + 1;
  val it = () : unit
  - !x;
  val it = 1 : int

p A vari√°vel #[code x] foi criada como uma refer√™ncia a uma posi√ß√£o de mem√≥ria
  |  que guarda um inteiro, onde foi colocado o valor zero (#[code 0]).

p Na avalia√ß√£o seguinte, o conte√∫do da posi√ß√£o de mem√≥ria referenciada por
  |  #[code x] foi incrementado. √â poss√≠vel ver na √∫ltima avalia√ß√£o que aquela
  |  posi√ß√£o de mem√≥ria agora guarda o valor #[code 1].

p: small As linguagens da fam√≠lia ML tamb√©m suportam que uma vari√°vel seja
  | associada a outro valor.

h3 Gerador de inteiros

p Vamos ent√£o ao c√≥digo!!! üòÉ

p Vamos criar um gerador de n√∫meros inteiros e uma fun√ß√£o que use este gerador
  | para gerar uma lista de n√∫meros inteiros.

p As assinaturas de nossas fun√ß√µes ser√£o:

pre.prettyprint: code.language-ml.
  val xrange : (int * int) -&gt; unit -&gt; int option
  val range : (int * int) -&gt; int list

p Tomei os nomes emprestados de#[=" "]
  a(href="https://docs.python.org/2.7/library/functions.html") Python 2.7
  | . #[code xrange] recebe como par√¢metro uma tupla de dois inteiros
  |  (#[code (int * int)]) e retorna uma fun√ß√£o que recebe uma#[=" "]
  a(href="https://en.wikipedia.org/wiki/Unit_type") unidade
  | , retornando uma ‚Äúop√ß√£o‚Äù de inteiro.

p A tupla recebidas por #[code xrange] representa o come√ßo e o fim da
  | reitera√ß√£o.

p Ent√£o o par√¢metro #[code (a, b)] representa matematicamente reitera√ß√£o sobre o
  | conjunto #[tt [a, b)].

p #[code range] recebe o mesmo tipo de par√¢metro que #[code xrange], retornando
  | a lista j√° composta.

p: span(class=["glyphicon", "glyphicon-alert mg-alert"])
  |  ‚Äî Mas o que diabos √© uma #[strong op√ß√£o] de inteiro?

p √â um valor que #[strong pode ser] ‚Äúalgum‚Äù (#[code SOME]) inteiro ou ‚Äúnenhum‚Äù
  |  (#[code NONE]).

pre.prettyprint: code.language-ml.
  - SOME 42;
  val it = SOME 42 : int option
  - NONE;
  val it = NONE : 'a option

p Usaremos #[code NONE] para marcar o fim da reitera√ß√£o. Precisamos tamb√©m de
  | um#[=" "]
  a(href="https://en.wikipedia.org/wiki/Closure_(computer_programming)")
    em closure
  |  para armazenar o pr√≥ximo retorno do gerador (j√° que geradores n√£o s√£o
  |  idempotentes). Usaremos um #[code int ref] para o #[em closure].

p: small Atualizei o c√≥digo removendo a necessidade de usar #[code fn].

pre.prettyprint: code.language-ml.
  local
    fun xrange' i finish () =
      if !i &gt;= finish then
        NONE
      else
        let
          val r = !i
        in
          i := !i + 1;
          SOME r
        end
  in
    fun xrange (start, finish) = xrange' (ref start) finish
  end

p Vamos testar nosso #[code xrange]:

pre.prettyprint: code.language-ml.
  - val x = range (0, 10);
  val x = fn : unit -&gt; int option
  - x ();
  val it = SOME 0 : int option
  - x ();
  val it = SOME 1 : int option
  - x ();
  val it = SOME 2 : int option
  - x ();
  val it = SOME 3 : int option
  - x ();
  val it = SOME 4 : int option
  - x ();
  val it = SOME 5 : int option
  - x ();
  val it = SOME 6 : int option
  - x ();
  val it = SOME 7 : int option
  - x ();
  val it = SOME 8 : int option
  - x ();
  val it = SOME 9 : int option
  - x ();
  val it = NONE : int option

p OK! Nossa fun√ß√£o se comporta como esperado! Agora precisamos criar a fun√ß√£o
  |  #[code range].

h3 Gerador para lista

p Para criar a fun√ß√£o #[code range], criaremos uma fun√ß√£o que receba um gerador
  |  e retorne uma lista de todos os valores gerados.

p Esta fun√ß√£o precisa de um acumulador: uma lista que come√ßa vazia (#[code nil])
  |  e vai sendo preenchida conforme o gerador √© reiterado. Ent√£o ela precisa
  | validar o gerador (passando a unidade como par√¢metro) e tratar o resultado:

pre.prettyprint: code.language-ml.
  fun genToList' (acc : int list) (gen : unit -&gt; int option) : int list =
    case gen () of NONE       =&gt; rev acc
      | SOME value =&gt; genToList' (value::acc) gen

p Perceba que, passando #[code value::acc], a lista √© gerada de tr√°s para
  |  frente. Portanto, ao recebermos o valor de parada (#[code NONE]),
  |  precisamos retornar a invers√£o do acumulador (#[code rev acc]).

p Nossa#[=" "]
  code genToList'
  |  tem assinatura#[=" "]
  code int list -&gt; (unit -&gt; t option) -&gt; t list
  | , o que significa que, se chamada com um √∫nico par√¢metro (o acumulador),
  | retorna uma fun√ß√£o com a assinatura#[=" "]
  code (unit -&gt; t option) -&gt; t list
  | . Vamos criar o variante com acumulador embutido:

pre.prettyprint: code.language-ml.
  val genToList = genToList' nil

p Podemos usar essa segunda fun√ß√£o para construir a fun√ß√£o #[code range].
  |  Colocando tudo junto:

pre.prettyprint: code.language-ml.
  local
    fun genToList' (acc : int list) (gen : unit -&gt; int option) : int list =
      case gen () of NONE       =&gt; rev acc
                   | SOME value =&gt; genToList' (value::acc) gen
    val genToList = genToList' nil
  in
    val range = genToList o xrange
  end

p A constru√ß√£o #[code o] funciona como #[tt o] de matem√°tica, por exemplo,
  |  #[tt fog(x)] √© o mesmo que #[tt f(g(x))].

p Vamos testar:

pre.prettyprint: code.language-ml.
  - range (0, 10);
  val it = [0,1,2,3,4,5,6,7,8,9] : int list

p <em>It works!!!</em> üòã

h3 Pr√≥ximo artigo

p No#[=" "]
  a(href=public.kodumaro._data.blog.url+"2016/03/sml-2.html") pr√≥ximo artigo
  |  vamos tornar o gerador mais robusto e gen√©rico com #[em structures] e
  |  #[em functors].
