p.mg-first No#[=" "]
  a(href=public.kodumaro._data.blog.url+"2016/03/sml.html") artigo anterior
  |  vimos como criar funções que retornem uma sequência de inteiros. Porém,
  | para estendê-las para gerarem uma sequência de caracteres, por exemplo,
  | teríamos de reescrever o código.

p Neste artigo mudaremos o código para torná-lo estensível a outros tipos usando
  |  um #[em functor].

p Módulos em Standard ML são chamados #[em structures] e podem ser instanciados
  |  sob demanda com o uso de #[em functors]. A primeira coisa que precisamos é
  |  da assinatura dos módulos gerados pelo #[em functor].

p Os módulos gerados precisam ter o tipo de dado (#[code t]), uma função para
  |  construir o gerador (#[code build]) e outra para converter o gerador em
  |  lista (#[code genToList]). A assinatura fica assim então:

pre.prettyprint: code.language-ml.
  signature GENERATOR =
  sig
    eqtype t
    val genToList : (unit -&gt; t option) -&gt; t list
    val build : (t * t) -&gt; unit -&gt; t option
  end

p Também precisamos da assinatura da #[em structure] usada como parâmetro do
  |  #[em functor]. Essa #[em structure] deve gerenciar a reiteração dos dados.
  |  Para tanto, deve conhecer o tipo de dado (#[code t]), ter uma função para
  |  fazer o passo, ou seja, incrementar o dado (#[code increment]), e outra
  |  para testar a condição de parada (#[code checkFinish]).

p A assinatura fica assim então:

pre.prettyprint: code.language-ml.
  signature GENERATOR' =
  sig
    eqtype t
    val increment : t ref -&gt; unit
    val checkFinish : t ref -&gt; t -&gt; bool
  end

p O #[em functor] terá praticamente o mesmo código de nossas funções originais,
  |  mas agora será extensível.

p Vamos então trazer o código para o #[em functor]:

pre.prettyprint: code.language-ml.
  functor Generator (G : GENERATOR') : GENERATOR =
  struct
    type t = G.t

    val genToList =
      let
        fun genToList' (acc : t list) (gen : unit -&gt; t option) : t list =
          case gen () of NONE       =&gt; rev acc
                       | SOME value =&gt; genToList' (value::acc) gen
      in
        genToList' nil
      end

    local
      fun build' i finish () =
        if G.checkFinish i finish then
          NONE
        else
          let
            val r = !i
          in
            G.increment i;
            SOME r
          end
    in
      fun build (start, finish) = build' (ref start) finish
    end
  end

p Repare que agora em vez de #[code int] estamos usando #[code t] (que é igual
  |  a #[code G.t]), e delegamos a verificação do fim da reiteração e o
  |  incremento da referência para #[code G].

p Resta agora recriar nossas funções originais. Como só nos interessam
  |  #[code xrange] e #[code range], podemos criar a #[code structure] como
  |  #[code local]:

pre.prettyprint: code.language-ml.
  local
    structure IntGenerator = Generator (struct
      type t = int

      fun increment v : unit = v := !v + 1
      and checkFinish i finish = !i &gt;= finish
    end)
  in
    val xrange = IntGenerator.build
    val range = IntGenerator.genToList o xrange
  end

p E para criar funções equivalentes para caracteres? A lógica é a mesma:

pre.prettyprint: code.language-ml.
  local
    structure StringGenerator = Generator (struct
      type t = char

      fun increment v : unit = v := chr (ord (!v) + 1)
      and checkFinish (i : char ref) (finish : char) = !i &gt; finish
    end)
  in
    val xcharseq = StringGenerator.build
    val strseq = implode o StringGenerator.genToList o StringGenerator.build
  end

p Veja que agora podemos com facilidade estender o lógica de criação de
  |  geradores para virtualmente qualquer tipo, com a ajuda do #[em functor].
