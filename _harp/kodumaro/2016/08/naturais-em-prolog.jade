img.pull-right(src="/img/swi.jpg" alt="Prolog")

p.mg-first O #[]
  a(href="https://pt.wikipedia.org/wiki/Cálculo_lambda") cálculo-λ
  |  lida apenas com um tipo de dado: funções. Porém, com funções, o tipo
  | numérico mais simples de ser representado, portanto o mais importante, são
  | os números naturais.

p A representação de números naturais pode parecer estranha à primeira vista,
  | mas se torna muito simples depois de entendida:

pre: code.
  0 ≡ λsz.z
  1 ≡ λsz.sz
  2 ≡ λsz.s(sz)
  3 ≡ λsz.s(s(sz))
  4 ≡ λsz.s(s(s(sz)))

p A lógica é a seguinte: são funções que recebem dois argumentos. O primeiro
  |  (#[code s]) deve ser uma função de incremento – cuja resposta é chamada
  |  “sucessor”, enquanto o segundo uma função que represente o zero
  |  (#[code z]).

p Para o zero, o sucessor não é aplicado (#[code z]); para o um é aplicado
  |  apenas uma vez (#[code sz], sucessor de zero); para o dois são feitos dois
  |  passos de sucessão (#[code s(sz)], sucessor do sucessor de zero); para o
  |  três, três passos (#[code s(s(sz))]); e assim por diante.

p Algumas linguagens de programação já incorporaram esse conceito para a
  |  representação de números. Por exemplo, #[]
  a(href="http://idris-lang.org") Idris
  |  define números naturais da seguinte forma (suprimindo #[em docstrings]):

pre.prettyprint: code.language-haskell.
  data Nat : Type where
    Z : Nat
    S : Nat -&gt; Nat

p Então #[code Z] é zero, #[code S Z] é um, #[code S (S Z)] é 2,
  |  #[code S (S (S Z))] é três, e assim por diante.


h3 Prolog

p Podemos emular esse comportamento em #[]
  a(href="http://www.swi-prolog.org/") Prolog
  | .

p Primeiro precisamos de um predicado que informe o que são números naturais
  |  segundo o cálculo-λ. Podemos usar #[code nat/1], seguindo a referência de
  |  Idris.

p Precisamos informar que #[code z] (zero) é um número natural, e que o sucessor
  |  de um número natural também é um número natural:

pre.prettyprint: code.language-prolog.
  nat(z).
  nat(s(N)) :- nat(N).

p Resolvido!


h3 Conversão para inteiro

p Precisamos agora de um predicado que faça a conversão para números inteiros.

p A forma mais simples seria:

pre.prettyprint: code.language-prolog.
  to_int(z, 0).
  to_int(s(N), R) :- to_int(N, R1), R is R1 + 1.

p Estaria resolvido, não fosse um problema: esta implementação pode gerar um
  |  estouro de pilha, já que cada instância de #[code to_int/2] precisa
  |  aguardar que todas suas filhas de recursão terminem para liberar memória.

p A forma de resolver isso é usando um acumulador para aproveitar o recurso de
  |  #[em tail-call optimisation].

p Então o predicado #[code to_int/2] vai apenas verificar se o valor verificado
  |  é natural, e delegar a resolução para o predicado #[code to_int/3].

p Esse outro predicado lida com os seguintes parâmetros: o número natural, o
  | acumulador (que deve ser iniciado como zero) e a resposta.

p Daí #[code to_int/2] vira:

pre.prettyprint: code.language-prolog.
  to_int(N, R) :- nat(N), to_int(N, 0, R).

p Já #[code to_int/3] responde o acumulador quando #[code N] for #[code z], caso
  |  contrário incrementa o acumulador e delega para a próxima instância da
  | recursão resolver:

pre.prettyprint: code.language-prolog.
  to_int(z, A, A).
  to_int(s(N), A, R) :- succ(A, A1), to_int(N, A1, R).

p Essa construção mágica onde o último parâmetro de um predicado é ligado ao
  | penúltimo do próximo predicado numa cadeia de conjunção lógica possui um
  |  açúcar sintático em Prolog com o operador #[code --&gt;], que suprimi do
  |  código os dois últimos parâmetros do predicado:

pre.prettyprint: code.language-prolog.
  to_int(z, A, A).
  to_int(s(N)) --&gt; succ, to_int(N).


h3 Conversão a partir de inteiro

p Podemos criar também um predicado que converta um número inteiro em natural. O
  | princípio é muito similar. Precisamos apenas de um predicado equivalente ao
  |  #[code succ/2] que calcule o sucessor natural:

pre.prettyprint: code.language-prolog.
  nsucc(N, s(N)) :- nat(N).

p Agora podemos fazer #[code from_int/2] e #[code from_int/3]:

pre.prettyprint: code.language-prolog.
  from_int(I, R) :- integer(I), I >= 0, from_int(I, z, R).

  from_int(0, A, A).
  from_int(I) --&gt; { I1 is I - 1 }, nsucc, from_int(I1).


h3 Tornando utilizável

p Já podemos usar nosso #[code natural.pl]:

pre: code
  | sh$ #[strong swipl -q]#[br/]
  | :- #[strong: ="[natural]."]#[br/]
  em true.#[br/]#[br/]
  | :- #[strong natural:to_int(z, X).]#[br/]
  em X = 0.#[br/]#[br/]
  | :- #[strong natural:to_int(s(s(s(z))), X).]#[br/]
  em X = 3.#[br/]#[br/]
  | :- #[strong natural:from_int(8, X).]#[br/]
  em X = s(s(s(s(s(s(s(s(z))))))))
  strong  .
  br/
  br/
  | :-

p Mas podemos gerar um executável. Primeiro precisamos de um predicado pra
  | servir de meta:

pre.prettyprint: code.language-prolog.
  go :- current_prolog_flag(argv, [Argv]),
        atom_to_term(Argv, I, []),
        from_int(I, N),
        writeln(N), !.
  go :- current_prolog_flag(os_argv, [_, '-x', Path | _]),
        file_base_name(Path, Script),
        format('use: ~w &lt;zero_or_positive_integer&gt;~n', [Script]).

p Agora precisamos converter o #[em script] em executável:

pre: code
  | sh$ #[strong swipl -q]#[br/]
  | :- #[strong: ="[library(qsave)]."]#[br/]
  em true.#[br/]#[br/]
  | :- #[strong: ="[natural]."]#[br/]
  em true.#[br/]#[br/]
  | :- #[]
  strong
    a(href="http://www.swi-prolog.org/pldoc/man?predicate=qsave_program%2f2") qsave_program
    | (natural, [init_file('natural.pl'), goal(natural:go), toplevel(halt)]).#[br/]
  em true.#[br/]#[br/]
  | :-

p Finalmente é só executar:

pre: code
  | sh$ #[strong .&#x2f;natural 12]#[br/]
  em s(s(s(s(s(s(s(s(s(s(s(s(z))))))))))))#[br/]
  | sh$


h3 Bônus: par ou ímpar

p Como bônus, seguem dois predicados para calcular se o número natural é par ou
  | ímpar:

pre.prettyprint: code.language-prolog.
  even(z).
  even(s(N)) :- odd(N).
  odd(N) :- &#x5c;+ even(N).

p Observação: #[code &#x5c;+] é negação lógica em Prolog; a parada tanto de
  |  #[code even/1] quanto de #[code odd/1] é #[code even(z)], que informa que
  |  zero é par.


hr/

p Código para baixar: #[]
  a(href="/misc/natural.pl") natural.pl
  | .
