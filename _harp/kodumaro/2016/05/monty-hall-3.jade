include ../../../_includes/list-group-item.jade

img.pull-right(src="/img/erlang.png" alt="Erlang")

p.mg-first Com o#[=" "]
  a(href="/misc/monty-hall/mh_mc.erl") mestre de cerimônias
  |  criado no#[=" "]
  a(href="/kodumaro/2016/05/monty-hall.html") primeiro artigo
  | , e o#[=" "]
  a(href="/misc/monty-hall/mh_guest.erl") convidado
  |  criado no#[=" "]
  a(href="/kodumaro/2016/05/monty-hall-2.html") segundo artigo
  | , podemos rodar o jogo!

p O jogo será um novo módulo, #[code mh_game]. Podemos começar pelos cabeçalhos
  |  obrigatórios:

pre.prettyprint: code.language-erlang.
  -module(mh_game).
  -export(play/0, play/1).

  -define(ROUNDS, 1000).

  -spec play() -&gt; integer().
  -spec play(Rounds :: integer()) -&gt; integer().

p A #[em macro] #[code -define/2] define o número de rodadas em mil. A função
  |  #[code play/0] roda o número padrão de rodadas, enquanto #[code play/1]
  |  roda um número determinado de rodadas.

p Vamos implementar #[em play/0] para rodar o número padrão de rodadas:

pre.prettyprint: code.language-erlang.
  play() -&gt; play(?ROUNDS).

p Nada mais complexo que isso. Agora #[code play/1] deve ser responsável por
  |  #[sup 1]levantar o mestre de cerimônias, #[sup 2]rodar a quantidade correta
  |  de rodadas e #[sup 3]encerrar o processo mestre de cerimônias.

p Como precisamos encerrar o processo do mestre de cerimônias, não podemos
  | simplesmente executar a chamada da rodada, ele precisa ignorar os erros para
  |  que #[code mh_mc:stop/1] seja executado em qualquer ocasião:

pre.prettyprint: code.language-erlang.
  play(Rounds) -&gt;
      mh_mc:start_link(),
      case catch play(Rounds, 0) of Response -> Response end,
      mh_mc:stop(),
      Response.

p Agora precisamos da função #[code play/2], que executará cada rodada.

p Sendo uma função recursiva, podemos escrever primeiro a condição de parada,
  | que é quando não há mais rodadas, retornando o acumulador:

pre.prettyprint: code.language-erlang.
  play(0, Score) -&gt; Score;

p O passo deve executar o seguinte procedimento:

+ul
  +li Perguntar ao convidado que porta ele deseja escolher
    |  (#[code mh_guest:choose/0]);
  +li Perguntar ao mestre de cerimônias qual outra ficou disponível
    |  (#[code mh_mc:suggest_another_door/1]);
  +li Perguntar ao convidado se ele quer mudar de porta
    |  (#[code mh_guest:change/2]);
  +li Perguntar ao mestre de cerimônias qual o prêmio por trás da porta
    | escolhida;
  +li Somar 1 ao acumulador se o convidado ganhou um carro.

p Segue então o código que executa este procedimento, acrescentando apenas um
  =" "
  code throw/1
  |  para levantar um exceção caso ocorra um erro:

pre.prettyprint: code.language-erlang.
  play(Rounds, Score) when Rounds &gt; 0 -&gt;
      FirstChoice = mh_guest:choose(),
      {ok, Other} = mh_mc:suggest_another_door(FirstChoice),
      Door = mh_guest:change(FirstChoice, Other),
      case mh_mc:get_prize(Door) of
          {ok, goat} -&gt; play(Rounds - 1, Score);
          {ok, car} -&gt; play(Rounds - 1, Score + 1);
          Other -&gt; throw(Other)
      end.

p Compile e rode. Meu resultado foi:

pre: code
  | sh$ #[strong erlc mh_game.erl]#[br/]
  | sh$ #[strong erl]#[br/]
  em
    | Erlang/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10]
    |  [hipe] [kernel-poll:false] [dtrace]#[br/]
  br/
  em Eshell V7.3  (abort with ^G)#[br/]
  | 1&gt; #[strong mh_game:play().]#[br/]
  em 325#[br/]
  | 2&gt; #[strong mh_game:play().]#[br/]
  em 320#[br/]
  | 3&gt; #[strong mh_game:play().]#[br/]
  em 348#[br/]
  | 4&gt; #[strong mh_game:play().]#[br/]
  em 336#[br/]
  | 5gt;

p Não importa quantas vezes rode, fica sempre próximo de 333 acertos em mil,
  | 333‰, ou seja 33,3%, uma chance em três.

p No entanto, se compilarmos com a #[em flag] #[code -Dchange], o resultado muda
  |  radicalmente:

pre: code
  | sh$ #[strong erlc -Dchange mh_game.erl][br/]
  | sh$ #[strong erl]#[br/]
  em
    | Erlang/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10]
    |  [hipe] [kernel-poll:false] [dtrace]#[br/]
  br/
  em Eshell V7.3  (abort with ^G)#[br/]
  | 1&gt; #[strong mh_game:play().]#[br/]
  em 645#[br/]
  | 2&gt; #[strong mh_game:play().]#[br/]
  em 673#[br/]
  | 3&gt; #[strong mh_game:play().]#[br/]
  em 681#[br/]
  | 3&gt; #[strong mh_game:play().]#[br/]
  em 665#[br/]
  | 4&gt;

p Novamente o resultado está sempre por volta do complementar, que são 667
  | acertos em mil, 667‰, 66,7%, duas em três.

p Com isso, está #[strong provado] o#[=" "]
  a(href="https://pt.wikipedia.org/wiki/Problema_de_Monty_Hall")
    | Paradoxo de Monty Hall
  | !

h3#arquivos-para-baixar Todos os arquivos para baixar

+ul
  +li: a(href="/misc/monty-hall/mh.hrl"): code mh.hrl
  +li: a(href="/misc/monty-hall/mh_mc.erl"): code mh_mc.erl
  +li: a(href="/misc/monty-hall/mh_guest.erl"): code mh_guest.erl
  +li: a(href="/misc/monty-hall/mh_game.erl"): code mh_game.erl
