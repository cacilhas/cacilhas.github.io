include ../../../_widgets/list-group-item.pug
.text-center: img(src=image alt=public.vortaro.title)

-
  let elmCore = "http://package.elm-lang.org/packages/elm-lang/core/latest"
  let vortaro20180115 = public.vortaro.repo.replace(
    "master",
    "efcb58a543308ba47930915d58939aaff12653ec"
  )

br/

p Após escrever o #[=""]
  a(href=`${public.kodumaro.blog.url}2018/01/vortaro-orig.html`) artigo
  |  sobre a versão #[em on-line] do Konsulta Vortaro, parei um tempo para olhar
  |  outros códigos em Elm e assim adequar meu código ao padrão comum da
  |  comunidade.

p Por isso, resolvi atualizar este artigo.

hr/

p.mg-first Como exercício de #[=""]
  a(href="https://pt.wikipedia.org/wiki/ML_(linguagem_de_programação)") ML
  | , decidi escrever uma #[=""]
  a(href="http://cacilhas.info/vortaro/") versão #[em on-line]
  |  do #[=""]
  a(href="https://bitbucket.org/cacilhas/konsulta-vortaro/")
    != public.vortaro.title
  | . Fiz em #[=""]
  a(href="http://elm-lang.org/") Elm
  | , uma linguagem ML que compila (ou #[em transpila]) para Javascript.

p O código pode ser encontrado #[=""]
  a(href=`${public.vortaro.repo}/Main.elm`) aqui
  | , e vou fazer uma pequena revisão.

h3 Abordagem

p Elm possui um #[=""]
  a(href="https://guide.elm-lang.org/architecture/") desenho de arquitetura
  |  bastante interessante, separando o código em modelo, atualização,
  |  visualização e inscrições.

p #[strong Modelo] (#[em model]) é um tipo definido pelo usuário para
  |  representar o estado da aplicação.

p #[strong Atualização] (#[em update]) é a função que é chamada cada vez que a
  |  aplicação precisa ser atualizada, inclusive na resolução de #[=""]
  a(href="https://www.haskell.org/tutorial/monads.html") mônadas
  | , em Elm representadas pelo tipo #[=""]
  a(href=`${elmCore}/Platform-Cmd`) comando
  | .

p #[strong Visualização] (#[em view]) é a função chamada cada vez que a página
  |  precisa ser renderizada.

p #[strong Incrições] (#[em subscriptions]) é a função que monitora e reage a
  |  eventos, retornando uma inscrição, que é avalida e transaformada em uma
  |  atualização.

p Para escrever o código, segui a arquitetura restritamente, deixando de fora
  |  apenas a camada de inscrições (#[em subscriptions]).

h3 Cabeçalho

p O cabeçalho do arquivo começa na #[=""]
  a(href=`${vortaro20180115}/Main.elm#L1`) primeira linha
  |  e vai até a sétima.

p A primeira linha, declaração do módulo, não é necessária aqui, uma vez que se
  |  trata do módulo principal (#[code Main]), mas resolvi ser metódico.

p As linha seguintes importam os módulos dos quais farei uso mais abaixo: #[=""]
  a(href="https://github.com/elm-lang/html"): code Html
  | , #[=""]
  a(href="https://github.com/elm-lang/http"): code Http
  |  e #[=""]
  a(href=`${elmCore}/Regex`): code Regex
  | .

p Desta fui mais criterioso e importei explicitamente os recursos em vez de
  |  usar #[code exposing (..)].

h3: em Entrypoint

p O ponto de entrada é a função #[code main], declarada na #[=""]
  a(href=`${vortaro20180115}/Main.elm#L10`) linha 10
  | . Sua assinatura é #[code Program Never Model Msg]:

+ul
  a(href=`${elmCore}/Platform#Program`)
    +li #[code Program] é a aplicação em si.
  a(href=`${elmCore}/Basics#Never`)
    +li #[code Never] nunca retorna.
  a(href=`${vortaro20180115}/Main.elm#L24`)
    +li #[code Model] é o modelo da aplicação.
  a(href=`${vortaro20180115}/Main.elm#L41`)
    +li #[code Msg] é o tipo que define as possíveis mensagens trocadas.

p A função chama #[=""]
  a(href="https://github.com/elm-lang/html/blob/master/src/Html.elm#L205")
    code Html.program
  | , que constrói a aplicação a partir de funções de #[em callback]:

+ul
  +li #[code(title="inicialização") init] retorna o modelo inicial vazio e
    |  dispara um comando (mônada) para ser executado e carregar o dicionário.
  +li #[code(title="visualização") view] função declarada no final do arquivo.
  +li #[code(title="atualização") update] declarada em sua própria camada.
  +li #[code(title="inscrições") subscriptions] lâmbda vazio.

h3 Modelo

p Além de definir o formato do estado da aplicação, a camada de modelo costuma
  |  ser responsável pela inicialização da aplicação. Como a inicialização foi
  |  muito simples, usei #[=""]
  a(href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Platform-Cmd#!")
    code Cmd.(!)
  |  com modelo vazio e a função #[code loadWordbook].


p A camada de modelo vai da
  |  #[=""]
  a(href=`${vortaro20180115}/Main.elm#L24`) linha 24
  |  até a linha 34.

p O modelo em si possui quatro atributos:

+ul
  +li #[code query] a busca feita pelo usuário.
  +li #[code content] o conteúdo a ser exibido.
  +li #[code wordbook] o dicionário de palavras em Esperanto.

p A busca pelo dicionário é feita pela função #[code loadWordbook], que usa o
  |  módulo #[code Http] para criar um comando (mônada) para trazer o conteúdo
  |  de #[code vortaro.text]. Ele usa o nome #[code Load] do tipo #[code Msg]
  |  para informar à função de atualização que foi resolvida a carga.

h3 Atualização

p Chegamos à camada de atualização, que vai da #[=""]
  a(href=`${vortaro20180115}/Main.elm#L41`) linha 41
  |  até a linha 83.

p A primeira coisa definida é o tipo #[code Msg], que classifica a troca de
  |  mensagens interna da aplicação. Este tipo possui duas apresentações: a
  |  busca feita pelo usuário (#[code Query]), e a carga do dicionário
  |  (#[code Load]).

p A função de atualização (#[code update]) trata a busca do usuário na #[=""]
  a(href=`${vortaro20180115}/Main.elm#L48`) linha 48
  | , a carga do dicionário na #[=""]
  a(href=`${vortaro20180115}/Main.elm#L51`) linha 51
  | , e na #[=""]
  a(href=`${vortaro20180115}/Main.elm#L54`) linha 54
  |  o tratamento de erros na leitura do dicionário.

p No tratamento da busca, se a #[em string] for maior que um carácter, ele chama
  |  a função #[code find] para selecionar o conteúdo exibido, caso contrário
  |  não exibe nada.

p No tratamento da carga, o dicionário é transformado em uma lista de
  |  #[em strings] e armazenado no modelo.

p A #[=""]
  a(href=`${vortaro20180115}/Main.elm#L71`) função #[code find]
  |  retorna uma #[em string] vazia caso a busca seja menor que dois
  |  caracteres. Caso contrário, filtra o dicionário de acordo com a busca
  |  usando #[=""]
  a(href="https://pt.wikipedia.org/wiki/Express%C3%A3o_regular")
    | expressão regular
  | , junta tudo em uma única #[em string] e a processa para exibição.

h3 Visualização

p A camada de visualização vai da #[=""]
  a(href=`${vortaro20180115}/Main.elm#L90`) linha 90
  |  até o final do arquivo, e é a coisa mais bizarras de Elm.

p O próprio código HTML é gerado usando código, o que me lembra muito a
  |  malfadada abordagem da plataforma #[=""]
  a(href="http://www.seaside.st/") Seaside
  | , que #[strong fracassou] justamente por optar por esta abordagem. O que fiz
  |  para minizar o problema foi tratar o arquivo gerado como uma aplicação, não
  |  uma página, e inseri-la na página de fato usando #[=""]
  a(href="https://www.w3schools.com/tags/tag_iframe.asp"): em iframe
  | .

p Então não vou me aprofundar nesta parte, trata-se apenas de uma alternativa
  |  grotesca para escrever HTML.

h3 Conclusão

p Está no ar a #[=""]
  a(href=public.vortaro.url) versão #[em on-line] do !{public.vortaro.title}
  | , com código fonte disponível em #[=""]
  a(href=public.vortaro.git) repositório #[code git]
  | .

p Achei a sintaxe e forma de programar de Elm muito mais parecidas com #[=""]
  a(href="https://www.haskell.org/") Haskell
  |  do que com linguagens ML de fato, apesar de ser impura como as demais
  |  linguagens da família, diferente da purista Haskell.

p A arquitetura é bem interessante, e a camada de visualização tende a ser o
  |  ponto fraco da linguagem.

p Espero tanto a #[=""]
  a(href=public.vortaro.url) aplicação !{public.vortaro.title}
  |  quanto este artigo possam ser úteis.
