include ../../../_widgets/list-group-item.pug
.text-center: img(src=image alt=public.vortaro.title)

-
  let elmCore = "http://package.elm-lang.org/packages/elm-lang/core/latest"
  let vortaro20180111 = public.vortaro.repo.replace(
    "master",
    "1f2f32a9515eb648f678d5de98096628d3ed863f"
  )

br/

p.mg-first Como exercício de #[=""]
  a(href="https://pt.wikipedia.org/wiki/ML_(linguagem_de_programação)") ML
  | , decidi escrever uma #[=""]
  a(href="http://cacilhas.info/vortaro/") versão #[em on-line]
  |  do #[=""]
  a(href="https://bitbucket.org/cacilhas/konsulta-vortaro/")
    != public.vortaro.title
  | . Fiz em #[=""]
  a(href="http://elm-lang.org/") Elm
  | , uma linguagem ML que compila (ou #[em transpila]) para Javascript.

p O código pode ser encontrado #[=""]
  a(href=`${public.vortaro.repo}/Main.elm`) aqui
  | , e vou fazer uma pequena revisão.

h3 Abordagem

p Elm possui um #[=""]
  a(href="https://guide.elm-lang.org/architecture/") desenho de arquitetura
  |  bastante interessante, separando o código em modelo, atualização e
  |  visualização, às vezes inscrição.

p #[strong Modelo] (#[em model]) é um tipo definido pelo usuário para
  |  representar o estado da aplicação.

p #[strong Atualização] (#[em update]) é a função que é chamada cada vez que a
  |  aplicação precisa ser atualizada, inclusive na resolução de #[=""]
  a(href="https://www.haskell.org/tutorial/monads.html") mônadas
  | , em Elm representadas pelo tipo #[=""]
  a(href=`${elmCore}/Platform-Cmd`) comando
  | .

p #[strong Visualização] (#[em view]) é a função chamada cada vez que a página
  |  precisa ser renderizada.

p Para escrever o código, segui a arquitetura restritamente, deixando de fora
  |  apenas a camada de inscrição (#[em subscription]).

h3 Cabeçalho

p O cabeçalho do arquivo começa na #[=""]
  a(href=`${vortaro20180111}/Main.elm#L1`) primeira linha
  |  e vai até a sétima.

p A primeira linha, declaração do módulo, não é necessária aqui, uma vez que se
  |  trata do módulo principal (#[code Main]), mas resolvi ser metódico.

p As linha seguintes importam os módulos dos quais farei uso mais abaixo: #[=""]
  a(href="https://github.com/elm-lang/html"): code Html
  | , #[=""]
  a(href="https://github.com/elm-lang/http"): code Http
  |  e #[=""]
  a(href=`${elmCore}/Regex`): code Regex
  | .

p Poderia (deveria) ter sido mais criterioso e importar explicitamente os
  |  recursos, mas usei #[code exposing (..)] para agilizar o desenvolvimento.
  |  A final de contas, escrevi esta aplicação na #[=""]
  u(title="13 de Dezembro de 2018") tarde de ontem
  | .

h3: em Entrypoint

p O ponto de entrada é a função #[code main], declarada na #[=""]
  a(href=`${vortaro20180111}/Main.elm#L10`) linha 10
  | . Sua assinatura é #[code Program Never Model Msg]:

+ul
  a(href=`${elmCore}/Platform#Program`)
    +li #[code Program] é a aplicação em si.
  a(href=`${elmCore}/Basics#Never`)
    +li #[code Never] nunca retorna.
  a(href=`${vortaro20180111}/Main.elm#L24`)
    +li #[code Model] é o modelo da aplicação.
  a(href=`${vortaro20180111}/Main.elm#L51`)
    +li #[code Msg] é o tipo que define as possíveis mensagens trocadas.

p A função chama #[=""]
  a(href="https://github.com/elm-lang/html/blob/master/src/Html.elm#L205")
    code Html.program
  | , que constrói a aplicação a partir de funções de #[em callback]:

+ul
  +li #[code init] inicialização.
  +li #[code update] atualização.
  +li #[code subscriptions] inscrições.
  +li #[code view] visualização.

h3 Modelo

p Além de definir o formato do estado da aplicação, a camada de modelo também
  |  é responsável pela inicialização da aplicação. A camada de modelo vai da
  |  #[=""]
  a(href=`${vortaro20180111}/Main.elm#L24`) linha 24
  |  até a linha 44.

p O modelo em si possui quatro atributos:

+ul
  +li #[code query] a busca feita pelo usuário.
  +li #[code content] o conteúdo a ser exibido.
  +li #[code wordbook] o dicionário de palavras em Esperanto.

p A função #[code init] returna o modelo inicial vazio e uma mônada para
  |  retornar o dicionário, que se encontra em #[=""]
  a(href=`${public.vortaro.url}/vortaro.text`): code vortaro.text
  | .

p A busca pelo dicionário é feita pela função #[code loadWordbook], que usa o
  |  módulo #[code Http] para criar um comando (mônada) para trazer o conteúdo
  |  de #[code vortaro.text]. Ele usa o nome #[code Load] do tipo #[code Msg]
  |  para informar à função de atualização que foi resolvida a carga.

h3 Atualização

p Chegamos à camada de atualização, que vai da #[=""]
  a(href=`${vortaro20180111}/Main.elm#L51`) linha 51
  |  até a linha 82.

p A primeira coisa definida é o tipo #[code Msg], que classifica a troca de
  |  mensagens interna da aplicação. Este tipo possui duas apresentações: a
  |  busca feita pelo usuário (#[code Query]), e a carga do dicionário
  |  (#[code Load]).

p A função de atualização (#[code update]) trata a busca do usuário na #[=""]
  a(href=`${vortaro20180111}/Main.elm#L58`) linha 58
  |  e a carga do dicionário na #[=""]
  a(href=`${vortaro20180111}/Main.elm#L71`) linha 71
  | . Na #[=""]
  a(href=`${vortaro20180111}/Main.elm#L74`) linha 74
  |  eu #[strong deveria] ter tratado erro na leitura do dicionário, mas isso
  |  ficará para um outro momento.

p No tratamento da busca, se a #[em string] for maior que um carácter, ele chama
  |  a função #[code find] para selecionar o conteúdo exibido, caso contrário
  |  não exibe nada.

p No tratamento da carga, o dicionário é transformado em uma lista de
  |  #[em strings] e armazenado no modelo.

p A #[=""]
  a(href=`${vortaro20180111}/Main.elm#L77`) função #[code find]
  |  filtra o dicionário de acordo com a busca usando #[=""]
  a(href="https://pt.wikipedia.org/wiki/Express%C3%A3o_regular")
    | expressão regular
  | , junta tudo em uma única #[em string] e a processa para exibição.

h3 Visualização

p A camada de visualização começa na #[=""]
  a(href=`${vortaro20180111}/Main.elm#L89`) linha 89
  |  e termina na linha 115, e é a coisa mais bizarras de Elm.

p O próprio código HTML é gerado usando código, o que me lembra muito a
  |  malfadada abordagem da plataforma #[=""]
  a(href="http://www.seaside.st/") Seaside
  | , que #[strong fracassou] justamente por optar por esta abordagem. O que fiz
  |  para minizar o problema foi tratar o arquivo gerado como uma aplicação, não
  |  uma página, e inseri-la na página de fato usando #[=""]
  a(href="https://www.w3schools.com/tags/tag_iframe.asp"): em iframe
  | .

p Então não vou me aprofundar nesta parte, trata-se apenas de uma alternativa
  |  grotesca para escrever HTML.

h3 Conclusão

p Está no ar a #[=""]
  a(href=public.vortaro.url) versão #[em on-line] do !{public.vortaro.title}
  | , com código fonte disponível em #[=""]
  a(href=public.vortaro.git) repositório #[code git]
  | .

p Achei a sintaxe e forma de programar de Elm muito mais parecidas com #[=""]
  a(href="https://www.haskell.org/") Haskell
  |  do que com linguagens ML de fato, apesar de ser impura como as demais
  |  linguagens da família, diferente da purista Haskell.

p A arquitetura é bem interessante, e a camada de visualização tende a ser o
  |  ponto fraco da linguagem.

p Espero tanto a #[=""]
  a(href=public.vortaro.url) aplicação !{public.vortaro.title}
  |  quanto este artigo possam ser úteis.
