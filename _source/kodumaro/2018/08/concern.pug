img.pull-right(src=image alt="Python")

p.mg-first Um recurso bacana em #[=""]
  a(href="https://www.ruby-lang.org/") Ruby
  |  é #[=""]
  a(href="https://api.rubyonrails.org/v5.1/classes/ActiveSupport/Concern.html")
    em concern
  | : este módulo do ActiveSupport abstrai a criação de #[em mixins], deixando
  |  muito simples e prático fazer #[=""]
  a(href="https://pt.wikipedia.org/wiki/Programação_orientada_a_aspecto")
    | programação orientada a aspecto
  | . Dê uma olhada lá na #[=""]
  a(href="https://api.rubyonrails.org/v5.1/classes/ActiveSupport/Concern.html")
    | documentação
  | , pois, logo no começo da página, há dois exemplos de #[em mixin], sem e com
  |  #[em concern], a título de comparação.

p Isso me fez pensar: e #[=""]
  a(href="https://www.python.org/") Python
  | ?

h3: em Mixins

p Já escrevi um #[=""]
  a(href=`${public.kodumaro.blog.url}2016/04/aspectos-2.html`)
    | artigo sobre #[em mixins]
  |  em Python, que deixa claro a complexidade quando fazemos a cola dos
  |  #[em mixins] na classe principal usando herança múltipla. Basta olhar a
  |  assinatura da classe para ver como isso pode ficar complicado com a adição
  |  de novos #[em mixins]:

pre.prettyprint: code.
  class Grades(SerialisableGradeMixin, PersistenceMixin, GradesMixin):

h3 #[em Concern] em Python

p Pensando nisso, resolvi implementar uma versão de #[em concern] em Python.

p O que precisamos fazer: a #[em factory] deve injetar no contexto em que ele
  |  for chamado métodos e atributos da classe #[em mixin].

p A primeira coisa que precisamos é ter acessível no corpo da função o contexto
  |  da criação da classe. Para isso usamos o módulo #[=""]
  a(href="https://docs.python.org/3/library/inspect.html"): code inspect
  | .

p O atributo #[code f_locals] do #[em frame], retornado pela função #[=""]
  a(href="https://docs.python.org/3/library/inspect.html#inspect.currentframe")
    code frame.currentframe()
  | , é equivalente a #[code locals()], mas queremos os “locais” do #[em frame]
  |  que chama nossa função. Esse é o #[code f_back]:

pre.prettyprint: code.
  context = inspect.currentframe().f_back.f_locals

p Já temos o contexto da criação da classe à disposição, agora só falta injetar
  |  nele o dicionário de atributos do #[em mixin]:

pre.prettyprint: code.
  context.update(aspect.__dict__)

p O corpo todo do módulo Python fica:

pre.prettyprint: code.
  # file: concerns.py
  import inspect

  def concern(aspect: type) -&gt; None:
    context = inspect.currentframe().f_back.f_locals
    context.update(aspect.__dict__)

p Só isso já é suficiente! Porém não temos garantias de que funcione, precisamos
  |  de testes.

h3 Teste unitário

p Para testar, vamos criar um #[em mixin] de serialização e usá-lo num classe
  |  muito simples de pessoa.

p O #[em mixin] terá dois métodos: um método de serialização e outro de classe
  |  de desserialização. Vamos usar #[=""]
  a(href="https://www.json.org/") JSON
  |  para a serialização, ordenando as chaves para facilitar os testes.

pre.prettyprint: code.
  # file: serial.py
  import json

  class SerialMixin:

    def serialize(self) -&gt; str:
      return json.dumps(self._asdict(), sort_keys=True)

    @classmethod
    def deserialize(cls, data: str):
      return cls(**json.loads(data))

p A classe pessoa será uma #[=""]
  a(href="https://docs.python.org/3/library/typing.html#typing.NamedTuple")
    tupla nomeada
  |  – porém tuplas em Python são primitivas e não suportam acesso à seu
  |  dicionário de atributos.

p Podemos contornar isso facilmente criando uma classe base, que será a tupla em
  |  si, e uma classe herdeira, que permite acesso ao dicionário de atributos:

pre.prettyprint: code.
  # file: person.py
  from typing import NamedTuple
  from concerns import concern
  from .serial import SerialMixin

  class PersonBase(NamedTuple):
    name: str
    surname: str

  class Person(PersonBase):
    concern(SerialMixin)

p Já temos a classe com uso de #[em mixin]. Vamos criar agora o teste, que
  |  verifica se instâncias de pessoa podem ser serializadas e desserializadas:

pre.prettyprint: code.
  # file: test_concern.py
  from unittest import TestCase
  from .person import Person

  class TestConcern(TestCase):

    def test_serialize(self):
      p = Person(name='John', surname='Doe')
      self.assertEqual(
        p.serialize(),
        '{"name": "John", "surname": "Doe"}',
      )

    def test_deserialize(self):
      p = Person.deserialize('{"name": "J", "surname": "Quest"}')
      self.assertIsInstance(p, Person)
      self.assertEqual(p.name, "J")
      self.assertEqual(p.surname, "Quest")

p Rodando os testes:

pre: code: p
  em sh&gt; #[=""]
  strong python3 -munittest test_concern.py
  br/
  em ..
  br/
  em ----------------------------------------------------------------------
  br/
  em Ran 2 tests in 0.000s
  br/
  br/
  em OK

h3 Voltando ao exemplo inicial

p E a classe #[code Grades] do #[=""]
  a(href=`${public.kodumaro.blog.url}2016/04/aspectos-2.html`) exemplo anterior
  | ?

p Usando nossa #[em factory], seu cabeçalho ficaria assim:

pre.prettyprint: code.
  class Grades:
    concern(SerialisableGradeMixin)
    concern(PersistenceMixin)
    concern(GradesMixin)

p Perceba que, nessa abordagem, a adição de novos #[em mixins] não suja a
  |  assintura da classe.
