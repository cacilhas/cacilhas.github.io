img.pull-right(src="/img/python.png" alt="Python")

p.mg-first √â muito comum programadores inexperientes desrespeitarem contratos
  | estabelecidos, algumas vezes por n√£o saberem como resolver uma situa√ß√£o de
  |  outra forma, outras por #[=""]
  a(href="https://pt.wikipedia.org/wiki/Efeito_Dunning-Kruger")
    efeito Dunning-Kruger
  | .

p Um dos erros mais comuns que tenho visto no mundo #[=""]
  a(href="http://python.org/") Python
  |  √© a quebra do contrato da classe #[=""]
  a(href="https://docs.python.org/3/library/unittest.html#unittest.TestCase")
    code TestCase
  | .

h3#metodos-hook M√©todos #[em hook]

p Geralmente a quebra de contrato ocorre porque o programador n√£o entende o
  |  conceito de <em>hook</em> ou n√£o sabe como evitar chamar #[code super] na
  |  heran√ßa.

p #[em Hook] √© aquele m√©todo preenchido pelo c√≥digo principal para ser chamado
  |  por um #[em framework]. Por defini√ß√£o, o #[em hook] n√£o deve ser chamado no
  |  c√≥digo de aplica√ß√£o, ou deve ser evitado. Em seu lugar √© feita chamada para
  |  alguma rotina do #[em framework] que, por sua fez, usa o #[em hook] dentro
  |  da conveni√™ncia do mesmo.

p Na biblioteca de #[em unit test] de Python, os m√©todos de #[code TestCase]
  |  #[code setUp] e #[code tearDown] (de inst√¢ncia), e #[code setUpClass] e
  |  #[code tearDownClass] s√£o m√©todos #[em hook], evocados pelo #[em framework]
  |  de teste unit√°rio.

h3#problema O problema

p O programador j√∫nior, muito satisfeito com seu entendimento sobre heran√ßa,
  | quer ent√£o aplicar o mesmo no m√°ximo de solu√ß√µes poss√≠veis e encontrou uma
  | abordagem em que a heran√ßa se encaixa como uma luva: nos testes unit√°rios,
  |  ele precisa iniciar uma sess√£o com o banco (um #[=""]
  a(href="https://www.sqlite.org/") SQLite
  | ) antes de cada teste, e encerr√°-lo ao final de cada um.

p Ele sabe que o m√©todo #[code setUp] √© executado antes de cada teste,
  |  enquanto o m√©todo #[code tearDown] √© executado ao final, havendo erro,
  |  falha ou sucesso. Perfeito!

p Mas ele precisa que todas as classes de teste usem esses m√©todos, ent√£o ele
  |  pensa numa solu√ß√£o que parece perfeita: implementar os m√©todos #[em hook]
  |  numa classe pai, que ser√° herdada pelas demais classes de teste.

p A coisa fica mais ou menos assim:

pre.prettyprint: code.language-python.
  import unittest
  import sqlite3
  import my_app

  __all__ = ['TestCase']


  class TestCase(unittest.TestCase):

      def setUp(self):
          conn = my_app.conn = sqlite3.connect(':memory:')
          conn.execute("""CREATE TABLE t_user (
                              id INTEGER PRIMARY KEY AUTOINCREMENT,
                              name TEXT,
                              birth DATE,
                              register INTEGER
                          )""")
          conn.commit()

      def tearDown(self):
          my_app.conn.close()

h3#novo-problema O novo problema

p Tudo ia √†s mil maravilhas, at√© nosso programador descobrir que, em um de seus
  | testes, ele precisa simular o comportamento de um acesso a um servidor
  =" "
  a(href="http://redis.io/") Redis
  | , o que sobrescreve sua perfeita solu√ß√£o de banco de dados!

p Qual a nova solu√ß√£o? O que se faz em heran√ßa: evocar #[code super]!

pre.prettyprint: code.language-python.
  from unittest.mock import patch
  from my_test_case import TestCase
  from my_app import CacheManager

  __all__ = ['TestCacheManager']


  class TestCacheManager(TestCase):

      def setUp(self):
          <strong>super().setUp()</strong>
          redis_patch = self.redis_patch = patch('my_app.Redis')
          self.redis = redis_patch.start()

      def tearDown(self):
          self.redis_patch.stop()
          <strong>super().tearDown()</strong>

      """Seguem os testes..."""

p O que nosso resoluto programador j√∫nior n√£o percebeu ‚Äì ou percebeu, mas n√£o
  |  sacou como resolver ‚Äì √© que o #[=""]
  strong contrato do #[code unittest] foi quebrado
  | .

h3#abordagem-correta A abordagem correta

p A regra de ouro do #[code unittest] √©: #[strong jamais] implemente m√©todos
  |  #[em hook] em classes que n√£o sejam testes de fato, que sejam abstra√ß√µes de
  |  comportamento para casos de teste de fato.

p ‚Äî Mas como resolver ent√£o? üòØ

p Como sua classe pai tem o objetivo de alterar o comportamento do
  |  #[em framework], sobrescreva rotinas internas do #[em framework].

p No caso, o m√©todo cujo comportamento voc√™ quer mudar √© #[code run]. A
  |  altera√ß√£o ser√° parecida com a cria√ß√£o de um contexto usando
  |  #[code contextlib.contextmanager], apenas trocando o #[code yield] por
  |  #[code super]:

pre.prettyprint: code.language-python.
  class TestCase(unittest.TestCase):

      def run(self, result=None):
          conn = my_app.conn = sqlite3.connect(':memory:')
          conn.execute("""CREATE TABLE t_user (
                              id INTEGER PRIMARY KEY AUTOINCREMENT,
                              name TEXT,
                              birth DATE,
                              register INTEGER
                          )""")
          conn.commit()

          try:
              return super().run(result=result)
          finally:
              conn.close()

p Pronto! O problema j√° est√° resolvido! Agora nossa classe #[code TestCase] j√°
  |  possui comportamento de #[em framework], e os #[em hooks] podem ser usados
  |  corretamente:

pre.prettyprint: code.language-python.
  class TestCacheManager(TestCase):

      def setUp(self):
          redis_patch = self.redis_patch = patch('my_app.Redis')
          self.redis = redis_patch.start()

      def tearDown(self):
          self.redis_patch.stop()

            """Seguem os testes..."""

h3#conclusao Conclus√£o

p Esses problemas s√£o causados por desentendimento dos contratos e
  | desconhecimento da linguagem, mas s√£o facilmente resolvidos com um pouco de
  | pesquisa e leitura dos c√≥digos das bibliotecas padr√£o, que s√£o muito bem
  | documentadas.
