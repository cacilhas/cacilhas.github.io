img.pull-right(src=image alt="")

p.mg-first Este artigo foi publicado originalmente em #[=""]
  a(href="http://kodumaro.blogspot.com.br/2013/09/introducao-ao-codigo-ascii-para.html")
    | 27 de setembro de 2013
  | .

p Código #[=""]
  a(href="http://www.unicode.org/charts/PDF/U0000.pdf") ASCII
  |  é a codificação de caracteres para valores numéricos de 7 #[em bits] mais
  |  aceita mundialmente e significa #[=""]
  em American Standard Code for Information Interchange
  |  – portanto, nada de ASC-2, por favor.

p O ASCII não permite acentos ou diacríticos, apenas os caracteres mais comuns
  | e uma série de 33 caracteres de controle. Porém, como a menor palavra
  |  binária (sequência de #[=""]
  a(href="http://pt.wikipedia.org/wiki/Bit"): em bits
  | ) usada é o #[=""]
  a(href="http://pt.wikipedia.org/wiki/Byte") #[em byte] ou octeto
  | , que usa 8 #[em bits], um a mais que o ASCII, é possível criar
  |  #[em supersets] com o dobro
  sup: a(href="#footnote-1") 1
  |  da capacidade como, por exemplo, o #[=""]
  a(href="http://pt.wikipedia.org/wiki/ISO_8859-1") Latin-1
  |  e o #[=""]
  a(href="http://en.wikipedia.org/wiki/Windows-1252") CP-1252
  | .

p Para quem está começando a tentar entender o código ASCII, é preciso saber
  | que ele é composto de grupos. O primeiro grupo é o que possui sequência
  |  binária #[code 00xxxxx], ou seja, zeros nas duas casas da esquerda e
  |  qualquer combinação nas 5 demais. Isso dá uma combinação de 32 caracteres,
  |  com código de 0 (#[code 0000000]) a 31 (#[code 0011111]), e consiste nos
  |  caracteres de controle, como nulo (0), os caracteres de mudança de linha
  |  (10 e 13), o #[em backspace] (8), o #[em escape] (27) e o #[em tab] (9).

p A única exceção de carácter de controle fora dessa sequência é o #[em delete]
  |  (127 – #[code 1111111]).

p O grupo seguinte, #[code 010xxxx] (32 a 47) é uma sequência de caracteres de
  |  pontuação e símbolos matemáticos, a começar pelo espaço (32).

p Então começam os números, dentro do grupo #[code 011xxxx]. Os números começam
  |  em #[code 0110000] (48) e seguem até #[code 0111001] (57). Uma forma fácil
  |  de pensar qual o código de um dígito numérico é somar 48 ao valor do
  | número. Por exemplo, o código de 7 é (48+7=) 55.

p O grupo #[code 011xxxx] segue com mais pontuações e símbolos matemáticos.

p O grupo seguinte é o das letras maiúsculas: #[code 10xxxxx]. O primeiro
  |  elemento, 64 (#[code 1000000]), é o arroba (#[code @]), seguido das letras.
  |  Para saber o código de uma letra é só somar 64 ao índice da letra no
  |  alfabeto. Por exemplo, a letra #[code F] é 6ª letra do alfabeto, portanto
  |  seu código é (64+6=) 70.

p Depois do #[code Z] (90), continuam mais pontuações e símbolos matemáticos,
  |  terminando com underscore (#[code _], 95 – #[code 1011111]).

p A próxima sequência, começando pela crase, são as letras minúsculas. A
  |  sequência é idêntica à anterior, apenas trocando o 6º #[em bit] (da direita
  |  pra esquerda) por 1: #[code 11xxxxx], o que soma 32 ao número, e as letras
  |  coincidem o mesmo código das maiúsculas.

p Ou seja, se o código de #[code F] é 70, o código de #[code f] é (70+32=) 102.

p Como esperado, a sequência após o #[code z] (122) continua com pontuações e
  |  símbolos matemáticos.

h3#exemplo Exemplo

p Como exemplo, vamos codificar a palavra #[code Kodumaro]:

pre: code.
  K = 64 + 11      =  75
  o = 64 + 15 + 32 = 111
  d = 64 +  4 + 32 = 100
  u = 64 + 21 + 32 = 117
  m = 64 + 13 + 32 = 109
  a = 64 +  1 + 32 =  97
  r = 64 + 18 + 32 = 114
  o = 64 + 15 + 32 = 111

  Kodumaro ≡ 75, 111, 100, 117, 109, 97, 114, 111

p Se você preferir, pode pensar em #[em bits] (incrívelmente mais simples): o 7º
  |  #[em bit] (mais à esquerda) é sempre #[code 1] (letra), o 6º é #[code 0]
  |  para maiúsculas e #[code 1] para minúsculas, os 5 seguintes são a ordem da
  | letra no alfabeto:

pre: code.
  A =  1 = 00001
  B =  2 = 00010
  C =  3 = 00011
  D =  4 = 00100
  E =  5 = 00101
  F =  6 = 00110
  G =  7 = 00111
  H =  8 = 01000
  I =  9 = 01001
  J = 10 = 01010
  K = 11 = 01011
  L = 12 = 01100
  M = 13 = 01101
  N = 14 = 01110
  O = 15 = 01111
  P = 16 = 10000
  Q = 17 = 10001
  R = 18 = 10010
  S = 19 = 10011
  T = 20 = 10100
  U = 21 = 10101
  V = 22 = 10110
  W = 23 = 10111
  X = 24 = 11000
  Y = 25 = 11001
  Z = 26 = 11010

p Voltando ao #[code Kodumaro]:

pre: code.
  K = (letra)(maiúscula)11ª – 1.0.01011 – 1001011
  o = (letra)(minúscula)15ª – 1.1.01111 – 1101111
  d = (letra)(minúscula) 4ª – 1.1.00100 – 1100100
  u = (letra)(minúscula)21ª – 1.1.10101 – 1110101
  m = (letra)(minúscula)13ª – 1.1.01101 – 1101101
  a = (letra)(minúscula) 1ª – 1.1.00001 – 1100001
  r = (letra)(minúscula)18ª – 1.1.10010 – 1110010
  o = (letra)(minúscula)15ª – 1.1.01111 – 1101111

p E de fato é assim que é codificado e armazenado:

pre: code.
  1001011.1101111.1100100.1110101.1101101.1100001.1110010.1101111

p Convertendo em #[em bytes] (palavras de 8 #[em bits]):

pre: code.
  0100101101101111011001000111010101101101011000010111001001101111

br/
br/

p.small
  sup#footnote-1 1
  | A cada bit que se acrescenta a uma palavra binária, sua quantidade de
  | combinações dobra.
