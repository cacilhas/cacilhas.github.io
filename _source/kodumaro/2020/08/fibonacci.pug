img.pull-right(src=image alt="Python")

p.mg-first One of the most interesting algorithms is the #[=""]
  a(href="https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF") Fibonacci
    |  numbers
  | . It’s pretty tricky ’cause it might leads to a binary tree recursion if
  |  coded carelessly.

p There’s a lot of ways to go around that issue, and I’d like to approach two
  |  of them using #[=""]
  a(href="https://cython.org/") Cython
  | .

h3 Accumulators and tail-call optimisation

p
  a(href="https://www.swi-prolog.org/") Prolog
  |  is a declarative logic programming language, consisting of describing
  |  the factual domain and then querying it.

p The simpliest (and #[strong wrong]) way to code Fibonacci in Prolog is:

pre.prettyprint: code.prolog.
  % vim: filetype=prolog
  :- module(fib, [fib/2]).

  fib(N, R) :- % step
    N &gt; 0,
    N1 is N - 1,
    N2 is N - 2,
    fib(N1, R1),
    fib(N2, R2),
    R is R1 + R2.

  fib(0, 1). % stop

p This describes Fibonacci number precisely, but #[strong don’t do it]. It
  |  dives into a binary tree, doubling the stack every step.

p The way to fix it is using two accumulators, #[code A] and #[code B]:

pre.prettyprint: code.prolog.
  % vim: filetype=prolog
  :- module(fib, [fib/2]).

  fib(N, R) :- N &gt;= 0, fib(N, 0, 1, R).

  fib(N, A, B, R) :- % step
    N &gt; 0,
    N1 is N - 1,
    AB is A + B,
    fib(N1, B, AB, R).

  fib(0, A, R, R). % stop

p Now it accumulates the values lineraly until the stop condition, when the
  |  last #[code B] is bound to #[code R].

p Try it:

pre.prettyprint: code.
  ?- [fib].
  true.

  ?- findall(X, (between(0, 5, I), fib(I, X)), R).
  R = [1, 1, 2, 3, 5, 8].

  ?-

p Prolog was used as basis for another programming language called #[=""]
  a(href="http://datalog.sourceforge.net/") Datalog
  | , focused on database query.

p The whole thing becomes simplier when Datalog comes into play. Let’s see the
  |  same domain coded in Datalog:

pre.prettyprint: code.datalog.
  fib(0, A, B, R) :- B = R.
  fib(N, A, B, R) :- N &gt; 0, fib(N-1, B, A+B, R).
  fib(N, R) :- N &gt;= 0, fib(N, 0, 1, R).

p And then:

pre.prettyprint: code.
  &gt; between(0, 5, I), fib(I, X)?
  fib(0, 1).
  fib(1, 1).
  fib(2, 2).
  fib(3, 3).
  fib(4, 5).
  fib(5, 8).
  &gt;

h3 Enter pyDatalog

p Python has a Datalog bind egg called #[=""]
  a(href="https://pypi.org/project/pyDatalog/") pyDatalog
  | , installed by a simple #[code pip]:

pre.prettyprint: code.
  python3.8 -mpip install pyDatalog

p You can use a #[=""]
  a(href="https://docs.python.org/3/library/venv.html") virtual environment
  | , or install directly into your system as root – your choice.

p We’re gonna need Cython too:

pre.prettyprint: code.
  python3.8 -mpip install cython

p In order to do some Datalog inside Python/Cython code, we need to declare the
  |  Datalog terms we’re using.

p This below is the very same Datalog code, using a #[code cpdef] to expose
  |  the #[code fib/2]:

pre.prettyprint: code.cython.
  #cython: language_level=3
  from libc.stdint cimport uint64_t
  from pyDatalog.pyParser import Term

  cdef:
      object _fib = Term()
      object A = Term()
      object B = Term()
      object R = Term()
      object N = Term()
      object X = Term()

  _fib(0, A, B, R) &lt;= (R == B)
  _fib(N, A, B, R) &lt;= (N &gt; 0) &amp; _fib(N-1, B, A+B, R)

  cpdef uint64_t fib(size_t n) except -1:
      _fib(n, 0, 1, X)
      return X.v()

p Now we need to compile it. Save it as #[code fib.pyx] and run:

pre.prettyprint: code.
  cythonize fib.pyx
  clang `python3.8-config --cflags` -fPIC -c fib.c
  clang -o fib.so `python3.8-config --libs` -shared fib.o

p (Or use #[code gcc].)

p It’s time to see it working. Open the #[=""]
  a(href="https://www.bpython-interpreter.org/"): code bpython
  | :

pre.prettyprint: code.
  &gt;&gt;&gt; from fib import fib
  &gt;&gt;&gt; [fib(i) for i in range(5)]
  [1, 1, 2, 3, 5, 8]
  &gt;&gt;&gt;

h3 Using matrices

p The Fibonacci numbers can also be represented as a #[=""]
  a(href="https://math.stackexchange.com/questions/61997/proof-of-this-result-related-to-fibonacci-numbers-beginpmatrix11-10-end")
    | matrix power
  |:

pre: code.
  │1 1│ⁿ
  │1 0│

p That’s a very elegant approach. We can do it by using #[=""]
  a(href="https://numpy.org/") NumPy
  | . First let’s install the egg just like before:

pre.prettyprint: code.
  python3.8 -mpip install numpy

p Now let’s recode Fibonacci using matrices:

pre.prettyprint: code.cython.
  #cython: language_level=3
  from libc.stdint cimport uint64_t
  from numpy cimport ndarray
  from numpy import matrix, uint64

  cdef:
      ndarray m = matrix('1, 1; 1, 0', dtype=uint64)

  cpdef uint64_t fib(size_t n) except -1:
      return (m ** n)[0, 0]

p NumPy represents the Fibonacci matrix as #[code '1, 1; 1, 0']. You can
  |  compile the code exactly the same way you did before, with the same
  |  results.

hr/

p: small Translated from the #[=""]
  a(href="https://kodumaro.blogspot.com/2015/04/brincadeira-rapida.html")
    | Portuguese post
  | .

+dev-to
