img.pull-right(src=image alt="Made with secret alien technology")

p.mg-first LISP é um conceito de programação funcional especificado em 1958
  |  por #[=""]
  a(href="http://www.genealogy.ams.org/id.php?id=22145")
    | John McCarthy
  | , que deu origem a uma família de linguagens. É baseado no #[=""]
  a(href="https://pt.wikipedia.org/wiki/C%C3%A1lculo_lambda")
    | cálculo-λ
  | , sistema formal de cálculo baseado em funções criado por #[=""]
  a(href="http://www.genealogy.ams.org/id.php?id=8011") Alonzo Church
  |  na década de 1930, e foi projetado para lidar com dados simbólicos, em
  |  oposição a dados numéricos, o padrão da maioria das linguagens imperativas.

p LISP significa #[em list processing], processamento de listas, e lista é a
  |  estrutura fundamental da linguagem. Todos os dados, assim como o código em
  |  si, são representados como listas.

p Por exemplo, a soma de 1 e 2 é escrita como:

pre.prettyprint: code.
  (+ 1 2)

p Que é lido como a lista dos elementos #[code +], #[code 1] e #[code 2]. O
  |  processamento da lista se dá separando o primeiro elemento (#[em head] ou
  |  #[code car]) dos demais (#[em tail] ou #[code cdr]):

pre.prettyprint: code.
  (+ . (1 2))

blockquote: small
  p: tt [update 2017-11-20]
  p Os termos #[code car] e #[code cdr] são comandos do #[=""]
    a(href="https://pt.wikipedia.org/wiki/IBM_704") IBM 704
    | , para o qual LISP foi desenvolvido. Significam #[=""]
    em Contents of the Address part of Register number
    |  e #[=""]
    em Contents of the Decrement part of Register number
    | .
  p: tt [/update]

p O primeiro elemento representa uma função λ e os demais elementos representam
  |  os parâmetros para esta função. No exemplo a função é #[code '+], que
  |  retorna a soma dos parâmetros, e os parâmetros são 1 e 2.

p As implementações / dialetos mais importantes de LISP são #[=""]
  a(href="https://common-lisp.net/") Common Lisp
  | , #[=""]
  a(href="https://www.gnu.org/software/emacs/manual/html_node/eintr/")
    | Emacs Lisp
  | , #[=""]
  a(href="http://www.schemers.org/") Scheme
  |  e #[=""]
  a(href="https://clojure.org/") Clojure
  | .

p Todos os dialetos de LISP seguem a mesma construção (funcional e
  |  processamento de listas), mas com variações nos nomes das funções e nas
  |  abordagens.

p Por exemplo, fatorial simples.

p Em Common Lisp:

pre.prettyprint: code.
  (defun factorial (n)
    (if (= n 0)
        1
        (* n (factorial (- n 1)))))

p Em Scheme R#[sup 5]RS:

pre.prettyprint: code.
  (define factorial
    (lambda (n)
      (if (zero? n)
          1
          (* n (factorial (- n 1))))))

p Em Clojure, a implementação recursiva do fatorial estoura a pilha da #[=""]
  a(href="https://www.java.com/") JVM
  | , então é preciso usar abordagens mais compatíveis com o funcionamento dela,
  |  como um #[em loop]:

pre.prettyprint: code.
  (defn factorial [x]
    (loop [n x f 1]
      (if (= n 1)
          f
          (recur (dec n) (* f n)))))

p Ou #[em map/reduce]:

pre.prettyprint: code.
  (defn factorial [n]
    (reduce * (range 1 (inc n))))


h3 Scheme

p Scheme por sua vez possui algumas implementações / variantes
  |  importantes: #[=""]
  a(href="https://www.gnu.org/software/guile/") Guile
  | , #[=""]
  a(href="https://www.gnu.org/software/mit-scheme/") MIT/GNU Scheme
  |  e #[=""]
  a(href="http://racket-lang.org/") Racket.

p Racket foi inicialmente chamado PLT-Scheme, depois renomeado para Racket. É
  |  uma plataforma #[=""]
  a(href="https://pt.wikipedia.org/wiki/Desenvolvimento_r%C3%A1pido_de_aplica%C3%A7%C3%B5es")
    | RAD
  |  completa, com #[=""]
  a(href="https://pt.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado")
    | IDE
  |  (
  a(href="https://docs.racket-lang.org/drracket/") DrRacket
  | ), gerador de interface #[=""]
  a(href="https://pt.wikipedia.org/wiki/WYSIWYG")
    | WYSIWYG
  |  (
  a(href="https://pkgs.racket-lang.org/package/mred-designer") MrEd Designer
  | ) e interpretador.

p Racket, enquanto plataforma de desenvolvimento, suporta uma série de
  |  liguagens, entre elas #[=""]
  a(href="http://www.schemers.org/Documents/Standards/R5RS/") R#[sup 5]RS
  | , #[=""]
  a(href="http://www.r6rs.org/") R#[sup 6]RS
  | , #[=""]
  a(href="http://docs.racket-lang.org/") Racket
  | , uma #[=""]
  a(href="http://docs.racket-lang.org/lazy/") versão #[em lazy]
  |  de Racket e até mesmo #[=""]
  a(href="https://planet.racket-lang.org/display.ss?package=c.plt&owner=jaymccarthy")
    | C
  | .

p Por exemplo, a implementação de fatorial acima pode ser implementada em Racket
  |  da seguinte forma:

pre.prettyprint: code.
  #!racket

  (define factorial
    (λ (n)
      [if (zero? n)
          1
          (* n (factorial (- n 1)))]))

p A primeira linha indica qual a linguagem usada. Outras possibilidades poderiam
  |  ser #[code #!r5rs] para R#[sup 5]RS, #[code #!r6rs] para R#[sup 6]RS ou
  |  #[code #!lazy] para Lazy Racket. Para C, o #[em hash bang] fica um pouco
  |  mais complexo:

pre.prettyprint: code.
  #!planet jaymccarthy/c

p A instrução #[code 'define] define o valor de um #[em slot], no caso
  |  #[code 'factorial], que armazena o resultado da lista no próximo parâmetro.

p A instrução #[code 'λ] cria uma função λ. O primeiro parâmetro é uma lista
  |  dos argumentos, o segundo parâmetro é o corpo da função.

p No caso a função é o resultado da instrução #[code 'if]: o primeiro parâmetro
  |  é a condição, o segundo o resultado em caso verdadeiro e o terceiro o
  |  resultado em caso falso.

p #[code zero?] retorna verdadeiro (#[code #t]) se o parâmetro for zero, ou
  |  falso (#[code #f]) se não for. O restante ficou fácil de entender agora.


h3 Continua…

p No #[=""]
  a(href=`${public.kodumaro.blog.url}2017/11/lazy-racket.html`) próximo artigo
  |  darei um exemplo de Lazy Racket, que usa #[em promises] para resolver
  |  algumas operações.
