img.pull-right(src=image alt="Julia Lang")

p.mg-first Uma ideia bacana em #[=""]
  a(href="https://julialang.org/") Julia
  |  é a relação entre #[=""]
  a(href="https://docs.julialang.org/en/stable/manual/functions/#") funções
  |  e #[=""]
  a(href="https://docs.julialang.org/en/stable/manual/methods/") métodos
  | .

p Por exemplo, inicie o #[em prompt] da linguagem:

pre: code: p
  em sh&gt; #[=""]
  strong julia
  br/
  |                #[=""]
  font(color="#00aa00") _
  br/
  |    #[=""]
  font(color="#0000aa") _
  |        _ #[=""]
  font(color="#aa0000") _
  font(color="#00aa00") (_)
  font(color="#aa00aa") _
  |      |  A fresh approach to technical computing
  br/
  |   #[=""]
  font(color="#0000aa") (_)
  |      | #[=""]
  font(color="#aa0000") (_)
  |  #[=""]
  font(color="#aa00aa") (_)
  |     |  Documentation: https://docs.julialang.org
  br/
  |    _ _   _| |_  __ _   |  Type "?help" for help.
  br/
  |   | | | | | | |/ _` |  |
  br/
  |   | | |_| | | | (_| |  |  Version 0.6.2 (2017-12-13 18:08 UTC)
  br/
  |  _/ |\__'_|_|_|\__'_|  |  Oaaicial http://julialang.org/ release
  br/
  | |__/                   |  x86_64-pc-linux-gnu
  br/
  br/
  em: font(color="#00aa00") julia&gt;

p Agora digite:

pre: code: p
  em julia&gt; #[=""]
  strong methods(+)
  br/
  | # 180 methods for generic function "+":

p Isso é seguido por cento e oitenta descrições de métodos. Vamos tomar dois
  |  métodos:

pre: code: p
  | +(x::Bool, y::Bool) in Base at bool.jl:89
  br/
  | +(x::T, y::T) where T&lt;:Number in Base at promotion.jl:335

p Isso significa que, quando chamamos a função #[code +] com dois booleanos:

pre: code: p
  em julia&gt; #[=""]
  strong true + true
  br/
  | 2

p Será executado o método #[code +(x::Bool, y::Bool)].

p Quando for chamado com dois valores numéricos:

pre: code: p
  em julia &gt; #[=""]
  strong 3 + 4
  br/
  | 7

p Será executado o método #[code +(x::T, y::T) where T&lt;:Number].

p Sempre que você escreve uma “função” em Julia, na verdade você está escrevendo
  |  um método que será chamado para aquela função, dados os tipos de parâmetro
  |  corretos.

p Se não houver um método para atender àquela assinatura específica, será
  |  levantado um erro de método (#[code MethodError]). Por exemplo:

pre: code: p
  em julia &gt; #[=""]
  strong :a + :b
  br/
  font(color="#aa0000") ERROR: MethodError: no method matching
    |  +(::Symbol, ::Symbol)
  br/
  | Closest candidates are:
  br/
  |   +(::Any, ::Any, #[=""]
  font(color="#aa0000") ::Any
  | , #[=""]
  font(color="#aa0000") ::Any...
  | ) at operators.jl:424

p Essa abordagem é ao mesmo tempo coerente com sobrecarga de funções em #[=""]
  a(href="https://en.wikipedia.org/wiki/Functional_programming#Type_systems")
    | programação funcional com tipos
  |  e com passagem de mensagens em #[=""]
  a(href="https://pt.wikipedia.org/wiki/Orientação_a_objetos")
    | orientação a objetos
  | .

h3: em Odd words

p Como exemplo de métodos diferentes para mesma função, vamos implementar uma
  |  brincadeira chamada #[em odd words]: dada uma frase, atribuindo um índice a
  |  cada palavra a partir de zero, o objetivo é inverter as palavras com índice
  |  ímpar.

p Para isso vamos criar um módulo que pode se chamar #[code oddwords.jl]:

pre.prettyprint: code.
  #!/usr/bin/env julia

  module OddWords

      #=
       = O código vai aqui
       =#

  end

p A inicialização do módulo vai passar os parâmetros da linha de comando
  |  (#[code ARGS]), aplicar a função #[code oddwords] e exibir na tela:

pre.prettyprint: code.
  __init__() = ARGS |&gt; oddwords |&gt; println

Agora vamos definir o primeiro método, que receberá um #[em array] de
  |  #[em strings]:

pre.prettyprint: code.
  oddwords(phrase::Array{String}) = oddwords(phrase, :even, "")

p Esse primeiro método repassa a outro método, indicando que o primeiro índice
  |  (zero) é par e passando como acumulador uma #[em string] vazia.

p O método seguinte, que tratará essa chamada, testará se a frase está vazia,
  |  caso contrário, inverterá (ou não) a palavra atual segundo a rodada:

pre.prettyprint: code.
  oddwords(phrase::Array{String}, round::Symbol, acc::String) =
      isempty(phrase) ? strip(acc) : odd_even(phrase, Val{round}, acc)

blockquote
  p: strong Observação:
  p O tipo #[=""]
    a(href="https://docs.julialang.org/en/stable/stdlib/base/#Base.Val")
      code Val
    |  é um recurso importante em Julia para permitir despacho de métodos
    |  baseado em valor em vez de tipo.

p O primeiro método da função #[code odd_even] tratará índice par, passando a
  |  primeira palavra (os índices de Julia começam em um) da frase para o
  |  acumulador, e chamando #[code oddwords] novamente, agora com o índice
  |  ímpar:

pre.prettyprint: code.
  odd_even(phrase::Array{String}, ::Type{Val{:even}}, acc::String) =
      oddwords(phrase[2:end], :odd, acc * " " * phrase[1])

p O próximo método tratará índice ímpar, fazendo o mesmo que o anterior, mas
  |  invertendo a palavra atual:

pre.prettyprint: code.
  odd_env(phrase::Array{String}, ::Type{Val{:odd}}, acc::String) =
      oddwords(phrase[2:end], :even, acc * " " * phrase[1][end:-1:1])

p Já é suficiente:

pre: code: p
  em sh&gt; #[=""]
  strong chmod +x oddwords.jl
  br/
  em sh&gt; #[=""]
  strong ./oddwords.jl esse teste verifica se as palavras serão invertidas
  br/
  | esse etset verifica es as sarvalap serão saditrevni

p Sucesso!

p O método correto é chamado de acordo com os tipos dos parâmetros:

pre: code: p
  em julia&gt; #[=""]
  strong include("oddwords.jl")
  br/
  br/
  | OddWords
  br/
  br/
  em julia&gt; #[=""]
  strong import OddWords
  br/
  br/
  em julia&gt; #[=""]
  strong methods(OddWords.oddwords)
  br/
  | # 2 methods for generic function "oddwords":
  br/
  | oddwords(phrase::Array{String,N} where N) in OddWords at ./oddwords.jl:7
  br/
  | oddwords(phrase::Array{String,N} where N, round::Symbol, acc::String) in OddWords at ./oddwords.jl:9
  br/
  br/
  em julia&gt; #[=""]
  strong methods(OddWords.odd_even)
  br/
  | # 2 methods for generic function "odd_even":
  br/
  | odd_even(phrase::Array{String,N} where N, ::Type{Val{:even}}, acc::String) in OddWords at ./oddwords.jl:12
  br/
  | odd_even(phrase::Array{String,N} where N, ::Type{Val{:odd}}, acc::String) in OddWords at ./oddwords.jl:15

