img.pull-right(src=image alt="Máquina de Turing")

p.mg-first O próximo elemento do interpretador #[=""]
  a(href="https://pt.wikipedia.org/wiki/Brainfuck") Brainfuck
  |  será a memória.

p O módulo #[code memory.pl] comerçará com o seguinte cabeçalho:

pre.prettyprint: code.
  % -*- Prolog -*-
  :- module(memory, []).
  :- [utils].

blockquote
  p Vamos precisar de um #[=""]
    a(href=`${public.misc.repo}/brainfuck/utils.pl`)
      | módulo auxiliar
    |  com alguns #[=""]
    a(href="http://www.swi-prolog.org/pldoc/man?section=metapred")
      | metapredicados
    |  úteis. Aqui utilizaremos #[code optional/1], que valida um outro
    |  predicado, resolvendo positivamente mesmo que o predicado parâmetro
    |  falhe.

  p Ele possui outro predicado útil, #[code finally/2], que usaremos mais para
    |  frente.

p Para que nossa memória possa armazenar estados, precisaremos de dois #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=(dynamic)/1")
    |  predicados dinâmicos
  |  para armezanar as células de estado (#[em slots]) e a posição da memória.

p Declaramos esses predicados no cabeçalho da seguinte forma:

pre.prettyprint: code.
  :- dynamic slot/3, pos/2.

p Usando a sintaxe de tipos de #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=must_be/2")
    code must_be/2
  | , cada estado terá o formato #[=""]
  code slot(name:atom, position:integer, value:integer)
  | , onde #[code name] é o nome da memória, #[code position] a posição da
  |  memória e #[code value] o valor armazenado. Respeitando os tipos, os três
  |  parâmetros são arbitrários. Cada marcador de posição terá o formato #[=""]
  code pos(name:atom, position:integer)
  | , onde #[code name] é o nome da memória e #[code position] a posição atual.

h3 Auxiliares para lidar com a posição da memória

p Como precisamos de um valor padrão quando a posição não estiver definida,
  |  vamos criar dois predicados auxiliares #[code get_pos/2] e
  |  #[code set_pos/2].

p O primeiro predicado precisa validar o valor do predicado dinâmico, se não
  |  resolver, resolve o valor para zero:

pre.prettyprint: code.
  get_pos(Name, Pos) :- pos(Name, Pos), !.
  get_pos(_, 0).

p O segundo predicado precisa #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=retract/1") retrair
  |  a verdade atual do predicado e #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=assertz/1") criar
  |  uma nova verdade. Para que a retração não falhe, usaremos
  |  #[code optional/1]:

pre.prettyprint: code.
  set_pos(Name, Pos) :- optional(retract(pos(Name, _))),
                        assertz(pos(Name, Pos)).

h3 Pegando o valor do #[em slot] de memória

p O predicado que valida o valor em memória deve considerar a célula atual, cuja
  |  posição é definida por #[code get_pos/2]. Portanto #[code get_slot/2] deve
  |  consultar a posição atual e repassar a responsabilidade para
  |  #[code get_slot/2] usando #[=""]
  a(href="https://en.wikipedia.org/wiki/Tail_call"): em tail-call optimisation
  | :

pre.prettyprint: code.
  get_slot(Name, Value) :- get_pos(Name, Pos),
                           get_slot(Name, Pos, Value).

blockquote
  p Ao contrário do #[=""]
    a(href=`${public.kodumaro.blog.url}2017/12/brainfuck-1.html`)
      | artigo anterior
    | , não vou comentar os testes, mas você pode vê-los no #[=""]
    a(href=`${public.misc.repo}/brainfuck/memory.pl`) código fonte
    | .

p A primeira verdade de nosso perdicado é quando coincide com alguma verdade do
  |  predicado dinâmico:

pre.prettyprint: code.
  get_slot(Name, Pos, Value) :- slot(Name, Pos, Value), !.

p A segunda verdade é que o valor é zero #[strong se] não existir uma verdade
  |  que coincida com o nome e a posição no predicado dinâmico:

pre.prettyprint: code.
  get_slot(Name, Pos, 0)     :- \+ slot(Name, Pos, _).

p O metapredicado #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=(%5C%2B)/1")
    code \+/1
  |  verifica se o predicado parâmetro falha.

p Agora precisamos de um predicado para mudar o valor da célula atual. Será
  |  regulado pelo mesmo princípio do #[em getter]:

pre.prettyprint: code.
  set_slot(Name, Value) :- get_pos(Name, Pos),
                           set_slot(Name, Pos, Value).

p Enquanto #[code set_slot/3] se comportará de modo parecido a
  |  #[code set_pos/2], retraindo a verdade atual e criando a nova:

pre.prettyprint: code.
  set_slot(Name, Pos, Value) :- optional(retract(slot(Name, Pos, _))),
                                assertz(slot(Name, Pos, Value)).

p Agora vamos exportar nossos predicados alterando o cabeçalho:

pre.prettyprint: code.
  :- module(memory, [get_slot/2, set_slot/2]).

h3 Incremento e decremento

p As operações mais comuns de mudança de valor de célula são incremento e
  |  decremento. Podemos implementá-las usando os predicados que já temos:

pre.prettyprint: code.
  incr_slot(Name) :- get_slot(Name, Value),
                     succ(Value, NewValue),
                     set_slot(Name, NewValue).

  decr_slot(Name) :- get_slot(Name, Value),
                     succ(NewValue, Value),
                     set_slot(Name, NewValue).

p O predicado #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=succ/2")
    code succ/2
  |  calcula o valor sucessor ou antecessor de valores naturais. Usando #[=""]
  a(href="https://pt.wikipedia.org/wiki/Cálculo_lambda") notação λ
  | , sucessor e antecessor são definidos como:

pre: code.
  SUCC := λx.sx
  PRED := λ(sx).x

p Fazendo a equivalência em Prolog:

pre: code
  p succ(#[em X], #[em S(X)]).

p Exportando agora:

pre.prettyprint: code.
  :- module(memory, [get_slot/2, set_slot/2, incr_slot/1, decr_slot/1]).

h3 Mudando de célula

p As operações para mudança de célula são mover para a próxima ou para a
  |  anterior, e são muito parecidas com incremento e decremento, a diferença
  |  é que, em vez do valor da célula, quem é incrementada ou decrementada é a
  |  posição:

pre.prettyprint: code.
  next_slot(Name) :- get_pos(Name, Pos),
                     succ(Pos, NewPos),
                     set_pos(Name, NewPos).

  prev_slot(Name) :- get_pos(Name, Pos),
                     succ(NewPos, Pos),
                     set_pos(Name, NewPos).

p Ao exportarmos, teremos terminado nossa memória:

pre.prettyprint: code.
  :- module(memory, [get_slot/2, set_slot/2, incr_slot/1, decr_slot/1
                     next_slot/1, prev_slot/1]).

h3 Arquivos

.text-center
  a(href=`${public.misc.repo}/brainfuck/utils.pl`)
    code utils.pl
  br/
  a(href=`${public.misc.repo}/brainfuck/memory.pl`)
    code memory.pl
