img.pull-right(src=image alt="Máquina de Turing")

p.mg-first O próximo elemento do interpretador #[=""]
  a(href="https://pt.wikipedia.org/wiki/Brainfuck") Brainfuck
  |  será a memória.

p O módulo #[code memory.pl] comerçará com o seguinte cabeçalho:

pre.prettyprint: code.
  % -*- Prolog -*-
  % @copyright ©2017, Rodrigo Cacilhας <batalema@cacilhas.info>
  :- module(memory, []).
  :- [utils].

blockquote
  p Vamos precisar de um #[=""]
    a(href=`${public.main.host}/misc/brainfuck/utils.pl`)
      | módulo auxiliar
    |  com alguns #[=""]
    a(href="http://www.swi-prolog.org/pldoc/man?section=metapred")
      | metapredicados
    |  úteis. Aqui utilizaremos #[code optional/1], que valida um outro
    |  predicado, resolvendo positivamente mesmo que o predicado parâmetro
    |  falhe.

  p Ele possui outro predicado útil, #[code finally/2], que usaremos mais para
    |  frente.

p Para que nossa memória possa armazenar estados, precisaremos de dois #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=(dynamic)/1")
    |  predicados dinâmicos
  |  para armezanar as células de estado (#[em slots]) e a posição da memória.

p Declaramos esses predicados no cabeçalho da seguinte forma:

pre.prettyprint: code.
  :- dynamic slot/3, pos/2.

p Usando a sintaxe de tipos de #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=must_be/2")
    code must_be/2
  | , cada estado terá o formato #[=""]
  code slot(name:atom, position:integer, value:integer)
  | , onde #[code name] é o nome da memória, #[code position] a posição da
  |  memória e #[code value] o valor armazenado. Respeitando os tipos, os três
  |  parâmetros são arbitrários. Cada marcador de posição terá o formato #[=""]
  code pos(name:atom, position:integer)
  | , onde #[code name] é o nome da memória e #[code position] a posição atual.

h3 Auxiliares para lidar com a posição da memória

p Como precisamos de um valor padrão quando a posição não estiver definida,
  |  vamos criar dois predicados auxiliares #[code get_pos/2] e
  |  #[code set_pos/2].

p O primeiro predicado precisa validar o valor do predicado dinâmico, se não
  |  resolver, resolve o valor para zero:

pre.prettyprint: code.
  get_pos(Name, Pos) :- pos(Name, Pos), !.
  get_pos(_, 0).

p O segundo predicado precisa #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=retract/1") recolher
  |  a verdade atual do predicado e #[=""]
  a(href="http://www.swi-prolog.org/pldoc/doc_for?object=assertz/1") criar
  |  uma nova verdade. Para que a retração não falhe, usaremos
  |  #[code optional/1]:

pre.prettyprint: code.
  set_pos(Name, Pos) :- optional(retract(pos(Name, _))),
                        assertz(pos(Name, Pos)).

h3 Pegando o valor do #[em slot] de memória

