img.pull-right(src="/img/glider.png" alt="")

p.mg-first Às vezes percebo que as pessoas apresentam dificuldade em entender
  |  a diferença entre um protocol texto e outro binário. Pretendo dar uma
  |  explicação bem simples.

p Texto ou binário significa a forma como os dados são representados em disco,
  |  memória ou na transmissão entre processos ou mesmo entre computadores.


h3 Protocolo binário

p A representação binária que vemos em arquivos binários, nos dados em memória
  |  de um programa em execução ou na transferência de dados em protocolos
  |  binários significa a representação mais direta possível dos dados em
  |  questão.

p Por exemplo: tomemos o número 98.765. Sua representação binária é
  |  1.1000.0001.1100.1101₂.

p Para a representação binária, a primeira coisa que precisamos considerar é
  |  seu tipo. Se imaginarmos que se trata de um inteiro de 64 #[em bits]
  |  (em #[=""]
  a(href="https://pt.wikipedia.org/wiki/C_(linguagem_de_programação)") C
  |  chamado #[code int]), ele será representado usando 4 #[em bytes]:

p.text-center 00000000.00000001.10000001.11001101

p Traduzindo em hexadecimal: 000181CD₁₆. É o equivalente a colocar zeros à
  |  esquerda de um número para completar as casas decimais.

p A maior parte dos processadores atuais usam representação #[=""]
  a(href="https://pt.wikipedia.org/wiki/Extremidade_(ordenação)#Armazenamento_do_valor_0x0A0B0C0D_na_memoria")
    em little-endian
  | , o que significa que o #[em byte] de menor relevância (equivalente à
  |  unidade) fica mais à esquerda, enquanto os mais relevantes ficam
  |  sucessivamente à direita.

p Dessa forma, o número 98.765 será representado como CD.81.01.00.

p Na comunicação de rede, usa-se #[em big-endian], que é justo o contrário: o
  |  #[em byte] mais relevante fica à esquerda: 00.01.81.CD.

p Em muitos protocolos de comunicação é fornecido um #[em byte] que indica o
  |  tipo do valor que o sucede. Digamos que em nosso protocolo, inteiro de
  |  64 #[em bits] seja representado pelo número 2. Então nosso dado seria
  |  codificado como 02.00.01.81.CD.

p Esse é o conceito de protocolo binário.


h3 Protocolo textual

p No protocolo texto ou textual, todos os dados são codificados como
  |  #[em strings], Então nosso número seria representado pelos códigos #[=""]
  a(href=`${public.kodumaro.blog.url}2016/05/ascii.html`) ASCII
  |  de cada dígito.

p Então 98.765 seria:

p.text-center 39.38.37.36.35

p No protocolo texto, sempre deve haver algum indicador do tamanho da
  |  #[em string]. Há duas abordagens mais comuns:

p A primeira é a usada em C: acrescentar um carácter nulo ao final da
  |  #[em string]: 39.38.37.36.35.00.

p A segunda abordagem é a de #[=""]
  a(href="https://pt.wikipedia.org/wiki/Pascal_(linguagem_de_programação)")
    | Pascal
  | : colocar o tamanho da #[em string] no primeiro #[em byte]:
  |  05.39.38.37.36.35.

p Como nosso protocolo é texto, não podemos usar 05 como representação, já que
  |  textualmente trata-se de um carácter de controle, precisamos então também
  |  usar uma representação de textual de tamanho, e um carácter de controle
  |  como separação. Os caracteres mais usados pra isso são o LF (0A) e o CR
  |  (0C). Vamos usar o CR: 30.35.0C.39.38.37.36.35.

p Colocando a comparação em perspectiva:

table.table
  thead
    tr
      th
      th Em memória
      th Em transferência

  tbody
    tr
      td: strong Binário
      td CD.81.01.00
      td 02.00.01.81.CD
    tr
      td: strong Texto
      td 39.38.37.36.35.00
      td 30.35.0C.39.38.37.36.35


h3 Dado textual

p Um caso interessante é o da própria #[em string].

p No protocolo binário, um texto é representado pelos códigos de seus
  |  caracteres. Por exemplo #[code Blog Kodumaro].

p Usando codificação C, em memória seria:
  |  41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.00.

p Para transmissão seria informado um primeiro valor para seu tipo (digamos que
  |  #[em string] seja 1) e um #[em byte] para seu comprimento:
  |  01.0D.41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.

p Em protocolo texto, geralmente são usados caracteres de começo e fim de
  |  #[em string], geralmente aspas (código 22₁₆).

p Então em memória seria 22.41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.22.00.

p Na transferência seria:
  |  31.35.0C.22.41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.22.

table.table
  thead
    tr
      th
      th Em memória
      th Em transferência

  tbody
    tr
      td: strong Binário
      td 41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.00
      td 01.0D.41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F
    tr
      td: strong Texto
      td 22.41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.22.00
      td 31.35.0C.22.41.6C.6F.67.20.4B.6F.64.75.6D.61.72.6F.22

p Espero ter exclarecido um pouco.


h3 Bônus: resposta HTTP

p Os dados acima seriam transferidos em protocolo HTTP (texto) da forma mais
  |  compacta como:

p.text-center 32 30 30 20 4F 4B 0D 0A 43 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 20 74 65 78 74 2F 70 6C 61 69 6E 0D 0A 43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 3A 20 35 0D 0A 0D 0A 39 38 37 36 35 0D 0A

p E:

p.text-center 32 30 30 20 4F 4B 0D 0A 43 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 20 74 65 78 74 2F 70 6C 61 69 6E 0D 0A 43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 3A 20 31 37 0D 0A 0D 0A 22 42 6C 6F 67 20 4B 6F 64 75 6D 61 72 6F 22 0D 0A

p Respectivamente.
